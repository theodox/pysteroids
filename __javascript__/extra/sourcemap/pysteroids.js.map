{
	"version": 3,
	"file": "/Users/stevet/prj/trans/__javascript__/pysteroids.js",
	"sources": [
		"",
		"/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/transcrypt/modules/org/transcrypt/__javascript__/__core__.mod.js",
		"/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/transcrypt/modules/org/transcrypt/__base__.py",
		"/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/transcrypt/modules/org/transcrypt/__standard__.py",
		"/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/transcrypt/modules/org/transcrypt/__javascript__/__builtin__.mod.js",
		"/Users/stevet/prj/trans/audio.py",
		"/Users/stevet/prj/trans/controls.py",
		"/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/transcrypt/modules/logging/__init__.py",
		"/Users/stevet/prj/trans/org/threejs/__init__.py",
		"/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/transcrypt/modules/random/__init__.py",
		"/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/transcrypt/modules/re/__init__.py",
		"/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/transcrypt/modules/re/translate.py",
		"/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/transcrypt/modules/time/__init__.py",
		"/Users/stevet/prj/trans/units.py",
		"/Users/stevet/prj/trans/utils.py",
		"/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/transcrypt/modules/warnings/__init__.py",
		"/Users/stevet/prj/trans/pysteroids.py"
	],
	"sourcesContent": [
		"__pragma__ ('padding')",
		"    var __all__ = {};\n    var __world__ = __all__;\n    \n    // Nested object creator, part of the nesting may already exist and have attributes\n    var __nest__ = function (headObject, tailNames, value) {\n        // In some cases this will be a global object, e.g. 'window'\n        var current = headObject;\n        \n        if (tailNames != '') {  // Split on empty string doesn't give empty list\n            // Find the last already created object in tailNames\n            var tailChain = tailNames.split ('.');\n            var firstNewIndex = tailChain.length;\n            for (var index = 0; index < tailChain.length; index++) {\n                if (!current.hasOwnProperty (tailChain [index])) {\n                    firstNewIndex = index;\n                    break;\n                }\n                current = current [tailChain [index]];\n            }\n            \n            // Create the rest of the objects, if any\n            for (var index = firstNewIndex; index < tailChain.length; index++) {\n                current [tailChain [index]] = {};\n                current = current [tailChain [index]];\n            }\n        }\n        \n        // Insert it new attributes, it may have been created earlier and have other attributes\n        for (var attrib in value) {\n            current [attrib] = value [attrib];          \n        }       \n    };\n    __all__.__nest__ = __nest__;\n    \n    // Initialize module if not yet done and return its globals\n    var __init__ = function (module) {\n        if (!module.__inited__) {\n            module.__all__.__init__ (module.__all__);\n            module.__inited__ = true;\n        }\n        return module.__all__;\n    };\n    __all__.__init__ = __init__;\n    \n    \n__pragma__ ('ifdef', '__esv6__')\n    // Proxy switch, controlled by __pragma__ ('proxy') and __pragma ('noproxy')\n    var __proxy__ = false;  // No use assigning it to __all__, only its transient state is important\n__pragma__ ('endif')\n    \n    \n    // Since we want to assign functions, a = b.f should make b.f produce a bound function\n    // So __get__ should be called by a property rather then a function\n    // Factory __get__ creates one of three curried functions for func\n    // Which one is produced depends on what's to the left of the dot of the corresponding JavaScript property\n    var __get__ = function (self, func, quotedFuncName) {\n        if (self) {\n            if (self.hasOwnProperty ('__class__') || typeof self == 'string' || self instanceof String) {           // Object before the dot\n                if (quotedFuncName) {                                   // Memoize call since fcall is on, by installing bound function in instance\n                    Object.defineProperty (self, quotedFuncName, {      // Will override the non-own property, next time it will be called directly\n                        value: function () {                            // So next time just call curry function that calls function\n                            var args = [] .slice.apply (arguments);\n                            return func.apply (null, [self] .concat (args));\n                        },              \n                        writable: true,\n                        enumerable: true,\n                        configurable: true\n                    });\n                }\n                return function () {                                    // Return bound function, code dupplication for efficiency if no memoizing\n                    var args = [] .slice.apply (arguments);             // So multilayer search prototype, apply __get__, call curry func that calls func\n                    return func.apply (null, [self] .concat (args));\n                };\n            }\n            else {                                                      // Class before the dot\n                return func;                                            // Return static method\n            }\n        }\n        else {                                                          // Nothing before the dot\n            return func;                                                // Return free function\n        }\n    }\n    __all__.__get__ = __get__;\n        \n    // Mother of all metaclasses        \n    var py_metatype = {\n        __name__: 'type',\n        __bases__: [],\n        \n        // Overridable class creation worker\n        __new__: function (meta, name, bases, attribs) {\n            // Create the class cls, a functor, which the class creator function will return\n            var cls = function () {                     // If cls is called with arg0, arg1, etc, it calls its __new__ method with [arg0, arg1, etc]\n                var args = [] .slice.apply (arguments); // It has a __new__ method, not yet but at call time, since it is copied from the parent in the loop below\n                return cls.__new__ (args);              // Each Python class directly or indirectly derives from object, which has the __new__ method\n            };                                          // If there are no bases in the Python source, the compiler generates [object] for this parameter\n            \n            // Copy all methods, including __new__, properties and static attributes from base classes to new cls object\n            // The new class object will simply be the prototype of its instances\n            // JavaScript prototypical single inheritance will do here, since any object has only one class\n            // This has nothing to do with Python multiple inheritance, that is implemented explictly in the copy loop below\n            for (var index = bases.length - 1; index >= 0; index--) {   // Reversed order, since class vars of first base should win\n                var base = bases [index];\n                for (var attrib in base) {\n                    var descrip = Object.getOwnPropertyDescriptor (base, attrib);\n                    Object.defineProperty (cls, attrib, descrip);\n                }           \n__pragma__ ('ifdef', '__esv6__')\n\n                for (var symbol of Object.getOwnPropertySymbols (base)) {\n                    var descrip = Object.getOwnPropertyDescriptor (base, symbol);\n                    Object.defineProperty (cls, symbol, descrip);\n                }\n                \n__pragma__ ('endif')\n            }\n            \n            // Add class specific attributes to the created cls object\n            cls.__metaclass__ = meta;\n            cls.__name__ = name;\n            cls.__bases__ = bases;\n            \n            // Add own methods, properties and own static attributes to the created cls object\n            for (var attrib in attribs) {\n                var descrip = Object.getOwnPropertyDescriptor (attribs, attrib);\n                Object.defineProperty (cls, attrib, descrip);\n            }\n__pragma__ ('ifdef', '__esv6__')\n\n            for (var symbol of Object.getOwnPropertySymbols (attribs)) {\n                var descrip = Object.getOwnPropertyDescriptor (attribs, symbol);\n                Object.defineProperty (cls, symbol, descrip);\n            }\n            \n__pragma__ ('endif')\n            // Return created cls object\n            return cls;\n        }\n    };\n    py_metatype.__metaclass__ = py_metatype;\n    __all__.py_metatype = py_metatype;\n    \n    // Mother of all classes\n    var object = {\n        __init__: function (self) {},\n        \n        __metaclass__: py_metatype, // By default, all classes have metaclass type, since they derive from object\n        __name__: 'object',\n        __bases__: [],\n            \n        // Object creator function, is inherited by all classes (so could be global)\n        __new__: function (args) {  // Args are just the constructor args       \n            // In JavaScript the Python class is the prototype of the Python object\n            // In this way methods and static attributes will be available both with a class and an object before the dot\n            // The descriptor produced by __get__ will return the right method flavor\n            var instance = Object.create (this, {__class__: {value: this, enumerable: true}});\n            \n__pragma__ ('ifdef', '__esv6__')\n        if ('__getattr__' in this || '__setattr__' in this) {\n            instance = new Proxy (instance, {\n                get: function (target, name) {\n                    var result = target [name];\n                    if (result == undefined) {  // Target doesn't have attribute named name\n                        return target.__getattr__ (name);\n                    }\n                    else {\n                        return result;\n                    }\n                },\n                set: function (target, name, value) {\n                    try {\n                        target.__setattr__ (name, value);\n                    }\n                    catch (exception) {         // Target doesn't have a __setattr__ method\n                        target [name] = value;\n                    }\n                    return true;\n                }\n            })\n        }\n__pragma__ ('endif')\n\n            // Call constructor\n            this.__init__.apply (null, [instance] .concat (args));\n\n            // Return constructed instance\n            return instance;\n        }   \n    };\n    __all__.object = object;\n    \n    // Class creator facade function, calls class creation worker\n    var __class__ = function (name, bases, attribs, meta) {         // Parameter meta is optional\n        if (meta == undefined) {\n            meta = bases [0] .__metaclass__;\n        }\n                \n        return meta.__new__ (meta, name, bases, attribs);\n    }\n    __all__.__class__ = __class__;\n    \n    // Define __pragma__ to preserve '<all>' and '</all>', since it's never generated as a function, must be done early, so here\n    var __pragma__ = function () {};\n    __all__.__pragma__ = __pragma__;\n    \n    ",
		"# This module is avaible both in the Python and Transcrypt environments\n# It is included in-between the __core__ and the __builtin__ module, so the latter can adapt __envir__\n# In Transcrypt, __base__ is available inline, it isn't nested and cannot be imported in the normal way\n\nclass __Envir__:\n    def __init__ (self):\n        self.interpreter_name = 'python'\n        self.transpiler_name = 'transcrypt'\n        self.transpiler_version = '3.6.25'\n        self.target_subdir = '__javascript__'\n        \n__envir__ = __Envir__ ()",
		"# This module is avaible solely in the Transcrypt environment\n# It is included after the __builtin__ module, since it uses its facilities\n# In Transcrypt, __standard__ is available inline, it isn't nested and cannot be imported in the normal way\n\n__pragma__ ('skip')\ncopy = Math = __typeof__ = __repr__ = document = console = window = 0\n__pragma__ ('noskip')\n\n__pragma__ ('notconv')  # !!! tconv gives a problem with __terminal__, needs investigation\n__pragma__ ('nokwargs')\n__pragma__ ('noalias', 'sort')\n\nclass Exception:\n    __pragma__ ('kwargs')\n    def __init__ (self, *args, **kwargs):\n        self.__args__ = args\n        try:\n            self.stack = kwargs.error.stack # Integrate with JavaScript Error object\n        except:\n            self.stack = 'No stack trace available'\n    __pragma__ ('nokwargs')\n        \n    def __repr__ (self):\n        if len (self.__args__):\n            return '{}{}'.format (self.__class__.__name__, repr (tuple (self.__args__)))\n        else:\n            return '{}()'.format (self.__class__.__name__)\n            \n    def __str__ (self):\n        if len (self.__args__) > 1:\n            return str (tuple (self.__args__))\n        elif len (self.__args__):\n            return str (self.__args__ [0])\n        else:\n            return ''\n        \nclass IterableError (Exception):\n    def __init__ (self, error):\n        Exception.__init__ (self, 'Can\\'t iterate over non-iterable', error = error)\n            \nclass StopIteration (Exception):\n    def __init__ (self, error):\n        Exception.__init__ (self, 'Iterator exhausted', error = error)\n        \nclass ValueError (Exception,):\n    def __init__ (self, error):\n        Exception.__init__ (self, 'Erroneous value', error = error)\n    \nclass KeyError (Exception,):\n    def __init__ (self, error):\n        Exception.__init__ (self, 'Invalid key', error = error)\n    \nclass AssertionError (Exception):\n    def __init__ (self, message, error):\n        if message:\n            Exception.__init__ (self, message, error = error)\n        else:\n            Exception.__init__ (self, error = error)\n\nclass NotImplementedError (Exception):\n    def __init__(self, message, error):\n        Exception.__init__(self, message, error = error)\n\nclass IndexError(Exception):\n    def __init__(self, message, error):\n        Exception.__init__(self, message, error = error)\n\nclass AttributeError(Exception):\n    def __init__(self, message, error):\n        Exception.__init__(self, message, error = error)\n\n# Warnings Exceptions\n# N.B. This is a limited subset of the warnings defined in\n# the cpython implementation to keep things small for now.\n\nclass Warning (Exception):\n    ''' Warning Base Class\n    '''\n    pass\n\nclass UserWarning (Warning):\n    pass\n\nclass DeprecationWarning (Warning):\n    pass\n\nclass RuntimeWarning (Warning):\n    pass\n\n__pragma__ ('kwargs')\n\ndef __sort__ (iterable, key = None, reverse = False):               # Used by py_sort, can deal with kwargs\n    if key:\n        iterable.sort (lambda a, b: 1 if key (a) > key (b) else -1) # JavaScript sort, case '==' is irrelevant for sorting\n    else:\n        iterable.sort ()                                            # JavaScript sort\n        \n    if reverse:\n        iterable.reverse ()\n        \ndef sorted (iterable, key = None, reverse = False):\n    if type (iterable) == dict:\n        result = copy (iterable.keys ()) \n    else:       \n        result = copy (iterable)\n        \n    __sort__ (result, key, reverse)\n    return result\n\n__pragma__ ('nokwargs')\n\ndef map (func, iterable):\n    return [func (item) for item in iterable]\n\n\ndef filter (func, iterable):\n    if func == None:\n        func = bool\n    return [item for item in iterable if func (item)]\n    \n__pragma__ ('ifdef', '__complex__')\nclass complex:\n    def __init__ (self, real, imag = None):\n        if imag == None:\n            if type (real) == complex:\n                self.real = real.real\n                self.imag = real.imag\n            else:\n                self.real = real\n                self.imag = 0\n        else:\n            self.real = real\n            self.imag = imag\n            \n    def __neg__ (self):\n        return complex (-self.real, -self.imag)\n        \n    def __exp__ (self):\n        modulus = Math.exp (self.real)\n        return complex (modulus * Math.cos (self.imag), modulus * Math.sin (self.imag))\n    \n    def __log__ (self):\n        return complex (Math.log (Math.sqrt (self.real * self.real + self.imag * self.imag)), Math.atan2 (self.imag, self.real))\n        \n    def __pow__ (self, other):  # a ** b = exp (b log a)\n        return (self.__log__ () .__mul__ (other)) .__exp__ ()\n        \n    def __rpow__ (self, real):  # real ** comp -> comp.__rpow__ (real)\n        return self.__mul__ (Math.log (real)) .__exp__ ()\n        \n    def __mul__ (self, other):\n        if __typeof__ (other) is 'number':\n            return complex (self.real * other, self.imag * other)\n        else:\n            return complex (self.real * other.real - self.imag * other.imag, self.real * other.imag + self.imag * other.real)\n        \n    def __rmul__ (self, real):  # real + comp -> comp.__rmul__ (real)\n        return complex (self.real * real, self.imag * real)\n        \n    def __div__ (self, other):\n        if __typeof__ (other) is 'number':\n            return complex (self.real / other, self.imag / other)\n        else:\n            denom = other.real * other.real + other.imag * other.imag\n            return complex (\n                (self.real * other.real + self.imag * other.imag) / denom,\n                (self.imag * other.real - self.real * other.imag) / denom\n            )\n        \n    def __rdiv__ (self, real):  # real / comp -> comp.__rdiv__ (real)\n        denom = self.real * self.real\n        return complex (\n            (real * self.real) / denom,\n            (real * self.imag) / denom\n        )\n        \n    def __add__ (self, other):\n        if __typeof__ (other) is 'number':\n            return complex (self.real + other, self.imag)\n        else:   # Assume other is complex\n            return complex (self.real + other.real, self.imag + other.imag)\n        \n    def __radd__ (self, real):  # real + comp -> comp.__radd__ (real)\n        return complex (self.real + real, self.imag)\n        \n    def __sub__ (self, other):\n        if __typeof__ (other) is 'number':\n            return complex (self.real - other, self.imag)\n        else:\n            return complex (self.real - other.real, self.imag - other.imag)\n        \n    def __rsub__ (self, real):  # real - comp -> comp.__rsub__ (real)\n        return complex (real - self.real, -self.imag)\n        \n    def __repr__ (self):\n        return '({}{}{}j)'.format (self.real, '+' if self.imag >= 0 else '', self.imag)\n            \n    def __str__ (self):\n        return __repr__ (self) [1 : -1]\n        \n__pragma__ ('endif')\n\nclass __Terminal__:\n    '''\n    Printing to either the console or to html happens async, but is blocked by calling window.prompt.\n    So while all input and print statements are encountered in normal order, the print's exit immediately without yet having actually printed\n    This means the next input takes control, blocking actual printing and so on indefinitely\n    The effect is that everything's only printed after all inputs are done\n    To prevent that, what's needed is to only execute the next window.prompt after actual printing has been done\n    Since we've no way to find out when that is, a timeout is used.\n    '''\n\n    def __init__ (self):\n        self.buffer = ''\n    \n        try:\n            self.element = document.getElementById ('__terminal__')\n        except:\n            self.element = None\n            \n        if self.element:\n            self.element.style.overflowX = 'auto'\n            self.element.style.boxSizing = 'border-box'\n            self.element.style.padding = '5px'\n            self.element.innerHTML = '_'\n        \n    __pragma__ ('kwargs')\n        \n    def print (self, *args, sep = ' ', end = '\\n'):\n        self.buffer = '{}{}{}'.format (self.buffer, sep.join ([str (arg) for arg in args]), end) [-4096 : ] \n        \n        if self.element:\n            self.element.innerHTML = self.buffer.replace ('\\n', '<br>')\n            self.element.scrollTop = self.element.scrollHeight\n        else:\n            console.log (sep.join ([str (arg) for arg in args]))\n        \n    def input (self, question):\n        self.print ('{}'.format (question), end = '')\n        answer = window.prompt ('\\n'.join (self.buffer.split ('\\n') [-16:]))\n        self.print (answer)\n        return answer\n        \n    __pragma__ ('nokwargs')\n    \n__terminal__ = __Terminal__ ()\n",
		"    var __call__ = function (/* <callee>, <this>, <params>* */) {   // Needed for __base__ and __standard__ if global 'opov' switch is on\n        var args = [] .slice.apply (arguments);\n        if (typeof args [0] == 'object' && '__call__' in args [0]) {        // Overloaded\n            return args [0] .__call__ .apply (args [1], args.slice (2));\n        }\n        else {                                                              // Native\n            return args [0] .apply (args [1], args.slice (2));\n        }\n    };\n    __all__.__call__ = __call__;\n\n    // Initialize non-nested modules __base__ and __standard__ and make its names available directly and via __all__\n    // They can't do that itself, because they're regular Python modules\n    // The compiler recognizes their names and generates them inline rather than nesting them\n    // In this way it isn't needed to import them everywhere\n\n    // __base__\n\n    __nest__ (__all__, '', __init__ (__all__.org.transcrypt.__base__));\n    var __envir__ = __all__.__envir__;\n\n    // __standard__\n\n    __nest__ (__all__, '', __init__ (__all__.org.transcrypt.__standard__));\n\n    var Exception = __all__.Exception;\n    var IterableError = __all__.IterableError;\n    var StopIteration = __all__.StopIteration;\n    var ValueError = __all__.ValueError;\n    var KeyError = __all__.KeyError;\n    var AssertionError = __all__.AssertionError;\n    var NotImplementedError = __all__.NotImplementedError;\n    var IndexError = __all__.IndexError;\n    var AttributeError = __all__.AttributeError;\n\n    // Warnings Exceptions\n    var Warning = __all__.Warning;\n    var UserWarning = __all__.UserWarning;\n    var DeprecationWarning = __all__.DeprecationWarning;\n    var RuntimeWarning = __all__.RuntimeWarning;\n\n    var __sort__ = __all__.__sort__;\n    var sorted = __all__.sorted;\n\n    var map = __all__.map;\n    var filter = __all__.filter;\n\n__pragma__ ('ifdef', '__complex__')\n    var complex = __all__.complex;\n__pragma__ ('endif')\n    __all__.print = __all__.__terminal__.print;\n    __all__.input = __all__.__terminal__.input;\n\n    var __terminal__ = __all__.__terminal__;\n    var print = __all__.print;\n    var input = __all__.input;\n\n    // Complete __envir__, that was created in __base__, for non-stub mode\n    __envir__.executor_name = __envir__.transpiler_name;\n\n    // Make make __main__ available in browser\n    var __main__ = {__file__: ''};\n    __all__.main = __main__;\n\n    // Define current exception, there's at most one exception in the air at any time\n    var __except__ = null;\n    __all__.__except__ = __except__;\n    \n     // Creator of a marked dictionary, used to pass **kwargs parameter\n    var __kwargtrans__ = function (anObject) {\n        anObject.__kwargtrans__ = null; // Removable marker\n        anObject.constructor = Object;\n        return anObject;\n    }\n    __all__.__kwargtrans__ = __kwargtrans__;\n\n    // 'Oneshot' dict promotor, used to enrich __all__ and help globals () return a true dict\n    var __globals__ = function (anObject) {\n        if (isinstance (anObject, dict)) {  // Don't attempt to promote (enrich) again, since it will make a copy\n            return anObject;\n        }\n        else {\n            return dict (anObject)\n        }\n    }\n    __all__.__globals__ = __globals__\n    \n    // Partial implementation of super () .<methodName> (<params>)\n    var __super__ = function (aClass, methodName) {        \n        // Lean and fast, no C3 linearization, only call first implementation encountered\n        // Will allow __super__ ('<methodName>') (self, <params>) rather than only <className>.<methodName> (self, <params>)\n        \n__pragma__ ('ifdef', '__esv6__')\n        for (let base of aClass.__bases__) {\n__pragma__ ('else')\n        for (var index = 0; index < aClass.__bases__.length; index++) {\n            var base = aClass.__bases__ [index];\n__pragma__ ('endif')\n            if (methodName in base) {\n               return base [methodName];\n            }\n        }\n\n        throw new Exception ('Superclass method not found');    // !!! Improve!\n    }\n    __all__.__super__ = __super__\n        \n    // Python property installer function, no member since that would bloat classes\n    var property = function (getter, setter) {  // Returns a property descriptor rather than a property\n        if (!setter) {  // ??? Make setter optional instead of dummy?\n            setter = function () {};\n        }\n        return {get: function () {return getter (this)}, set: function (value) {setter (this, value)}, enumerable: true};\n    }\n    __all__.property = property;\n    \n    // Conditional JavaScript property installer function, prevents redefinition of properties if multiple Transcrypt apps are on one page\n    var __setProperty__ = function (anObject, name, descriptor) {\n        if (!anObject.hasOwnProperty (name)) {\n            Object.defineProperty (anObject, name, descriptor);\n        }\n    }\n    __all__.__setProperty__ = __setProperty__\n    \n    // Assert function, call to it only generated when compiling with --dassert option\n    function assert (condition, message) {  // Message may be undefined\n        if (!condition) {\n            throw AssertionError (message, new Error ());\n        }\n    }\n\n    __all__.assert = assert;\n\n    var __merge__ = function (object0, object1) {\n        var result = {};\n        for (var attrib in object0) {\n            result [attrib] = object0 [attrib];\n        }\n        for (var attrib in object1) {\n            result [attrib] = object1 [attrib];\n        }\n        return result;\n    };\n    __all__.__merge__ = __merge__;\n\n    // Manipulating attributes by name\n    \n    var dir = function (obj) {\n        var aList = [];\n        for (var aKey in obj) {\n            aList.push (aKey);\n        }\n        aList.sort ();\n        return aList;\n    };\n    __all__.dir = dir;\n\n    var setattr = function (obj, name, value) {\n        obj [name] = value;\n    };\n    __all__.setattr = setattr;\n\n    var getattr = function (obj, name) {\n        return obj [name];\n    };\n    __all__.getattr= getattr;\n\n    var hasattr = function (obj, name) {\n        try {\n            return name in obj;\n        }\n        catch (exception) {\n            return false;\n        }\n    };\n    __all__.hasattr = hasattr;\n\n    var delattr = function (obj, name) {\n        delete obj [name];\n    };\n    __all__.delattr = (delattr);\n\n    // The __in__ function, used to mimic Python's 'in' operator\n    // In addition to CPython's semantics, the 'in' operator is also allowed to work on objects, avoiding a counterintuitive separation between Python dicts and JavaScript objects\n    // In general many Transcrypt compound types feature a deliberate blend of Python and JavaScript facilities, facilitating efficient integration with JavaScript libraries\n    // If only Python objects and Python dicts are dealt with in a certain context, the more pythonic 'hasattr' is preferred for the objects as opposed to 'in' for the dicts\n    var __in__ = function (element, container) {\n        if (py_typeof (container) == dict) {        // Currently only implemented as an augmented JavaScript object\n            return container.hasOwnProperty (element);\n        }\n        else {                                      // Parameter 'element' itself is an array, string or a plain, non-dict JavaScript object\n            return (\n                container.indexOf ?                 // If it has an indexOf\n                container.indexOf (element) > -1 :  // it's an array or a string,\n                container.hasOwnProperty (element)  // else it's a plain, non-dict JavaScript object\n            );\n        }\n    };\n    __all__.__in__ = __in__;\n\n    // Find out if an attribute is special\n    var __specialattrib__ = function (attrib) {\n        return (attrib.startswith ('__') && attrib.endswith ('__')) || attrib == 'constructor' || attrib.startswith ('py_');\n    };\n    __all__.__specialattrib__ = __specialattrib__;\n\n    // Len function for any object\n    var len = function (anObject) {\n        if (anObject) {\n            var l = anObject.length;\n            if (l == undefined) {\n                var result = 0;\n                for (var attrib in anObject) {\n                    if (!__specialattrib__ (attrib)) {\n                        result++;\n                    }\n                }\n                return result;\n            }\n            else {\n                return l;\n            }\n        }\n        else {\n            return 0;\n        }\n    };\n    __all__.len = len;\n\n    // General conversions\n\n    function __i__ (any) {  //  Conversion to iterable\n        return py_typeof (any) == dict ? any.py_keys () : any;\n    }\n\n    function __t__ (any) {  // Conversion to truthyness, __ ([1, 2, 3]) returns [1, 2, 3], needed for nonempty selection: l = list1 or list2]\n        return (['boolean', 'number'] .indexOf (typeof any) >= 0 || any instanceof Function || len (any)) ? any : false;\n        // JavaScript functions have a length attribute, denoting the number of parameters\n        // Python objects are JavaScript functions, but their length doesn't matter, only their existence\n        // By the term 'any instanceof Function' we make sure that Python objects aren't rejected when their length equals zero\n    }\n    __all__.__t__ = __t__;\n\n    var bool = function (any) {     // Always truly returns a bool, rather than something truthy or falsy\n        return !!__t__ (any);\n    };\n    bool.__name__ = 'bool';         // So it can be used as a type with a name\n    __all__.bool = bool;\n\n    var float = function (any) {\n        if (any == 'inf') {\n            return Infinity;\n        }\n        else if (any == '-inf') {\n            return -Infinity;\n        }\n        else if (isNaN (parseFloat (any))) {    // Call to parseFloat needed to exclude '', ' ' etc.\n            throw ValueError (new Error ());\n        }\n        else {\n            return +any;\n        }\n    };\n    float.__name__ = 'float';\n    __all__.float = float;\n\n    var int = function (any) {\n        return float (any) | 0\n    };\n    int.__name__ = 'int';\n    __all__.int = int;\n\n    var py_typeof = function (anObject) {\n        var aType = typeof anObject;\n        if (aType == 'object') {    // Directly trying '__class__ in anObject' turns out to wreck anObject in Chrome if its a primitive\n            try {\n                return anObject.__class__;\n            }\n            catch (exception) {\n                return aType;\n            }\n        }\n        else {\n            return (    // Odly, the braces are required here\n                aType == 'boolean' ? bool :\n                aType == 'string' ? str :\n                aType == 'number' ? (anObject % 1 == 0 ? int : float) :\n                null\n            );\n        }\n    };\n    __all__.py_typeof = py_typeof;\n\n    var isinstance = function (anObject, classinfo) {\n        function isA (queryClass) {\n            if (queryClass == classinfo) {\n                return true;\n            }\n            for (var index = 0; index < queryClass.__bases__.length; index++) {\n                if (isA (queryClass.__bases__ [index], classinfo)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        if (classinfo instanceof Array) {   // Assume in most cases it isn't, then making it recursive rather than two functions saves a call\n__pragma__ ('ifdef', '__esv6__')\n            for (let aClass of classinfo) {\n__pragma__ ('else')\n            for (var index = 0; index < classinfo.length; index++) {\n                var aClass = classinfo [index];\n__pragma__ ('endif')\n                if (isinstance (anObject, aClass)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        try {                   // Most frequent use case first\n            return '__class__' in anObject ? isA (anObject.__class__) : anObject instanceof classinfo;\n        }\n        catch (exception) {     // Using isinstance on primitives assumed rare\n            var aType = py_typeof (anObject);\n            return aType == classinfo || (aType == bool && classinfo == int);\n        }\n    };\n    __all__.isinstance = isinstance;\n\n    var callable = function (anObject) {\n        if ( typeof anObject == 'object' && '__call__' in anObject ) {\n            return true;\n        }\n        else {\n            return typeof anObject === 'function';\n        }\n    };\n    __all__.callable = callable;\n\n    // Repr function uses __repr__ method, then __str__, then toString\n    var repr = function (anObject) {\n        try {\n            return anObject.__repr__ ();\n        }\n        catch (exception) {\n            try {\n                return anObject.__str__ ();\n            }\n            catch (exception) { // anObject has no __repr__ and no __str__\n                try {\n                    if (anObject == null) {\n                        return 'None';\n                    }\n                    else if (anObject.constructor == Object) {\n                        var result = '{';\n                        var comma = false;\n                        for (var attrib in anObject) {\n                            if (!__specialattrib__ (attrib)) {\n                                if (attrib.isnumeric ()) {\n                                    var attribRepr = attrib;                // If key can be interpreted as numerical, we make it numerical\n                                }                                           // So we accept that '1' is misrepresented as 1\n                                else {\n                                    var attribRepr = '\\'' + attrib + '\\'';  // Alpha key in dict\n                                }\n\n                                if (comma) {\n                                    result += ', ';\n                                }\n                                else {\n                                    comma = true;\n                                }\n                                result += attribRepr + ': ' + repr (anObject [attrib]);\n                            }\n                        }\n                        result += '}';\n                        return result;\n                    }\n                    else {\n                        return typeof anObject == 'boolean' ? anObject.toString () .capitalize () : anObject.toString ();\n                    }\n                }\n                catch (exception) {\n                    console.log ('ERROR: Could not evaluate repr (<object of type ' + typeof anObject + '>)');\n                    console.log (exception);\n                    return '???';\n                }\n            }\n        }\n    };\n    __all__.repr = repr;\n\n    // Char from Unicode or ASCII\n    var chr = function (charCode) {\n        return String.fromCharCode (charCode);\n    };\n    __all__.chr = chr;\n\n    // Unicode or ASCII from char\n    var ord = function (aChar) {\n        return aChar.charCodeAt (0);\n    };\n    __all__.org = ord;\n\n    // Maximum of n numbers\n    var max = Math.max;\n    __all__.max = max;\n\n    // Minimum of n numbers\n    var min = Math.min;\n    __all__.min = min;\n\n    // Absolute value\n__pragma__ ('ifdef', '__complex__')\n    var abs = function (x) {\n        try {\n            return Math.abs (x);\n        }\n        catch (exception) {\n            return Math.sqrt (x.real * x.real + x.imag * x.imag);\n        }\n    };\n__pragma__ ('else')\n    var abs = Math.abs;\n    __all__.abs = abs;\n__pragma__ ('endif')\n\n    // Bankers rounding\n    var round = function (number, ndigits) {\n        if (ndigits) {\n            var scale = Math.pow (10, ndigits);\n            number *= scale;\n        }\n\n        var rounded = Math.round (number);\n        if (rounded - number == 0.5 && rounded % 2) {   // Has rounded up to odd, should have rounded down to even\n            rounded -= 1;\n        }\n\n        if (ndigits) {\n            rounded /= scale;\n        }\n\n        return rounded;\n    };\n    __all__.round = round;\n\n    // BEGIN unified iterator model\n\n    function __jsUsePyNext__ () {       // Add as 'next' method to make Python iterator JavaScript compatible\n        try {\n            var result = this.__next__ ();\n            return {value: result, done: false};\n        }\n        catch (exception) {\n            return {value: undefined, done: true};\n        }\n    }\n\n    function __pyUseJsNext__ () {       // Add as '__next__' method to make JavaScript iterator Python compatible\n        var result = this.next ();\n        if (result.done) {\n            throw StopIteration (new Error ());\n        }\n        else {\n            return result.value;\n        }\n    }\n\n    function py_iter (iterable) {                   // Alias for Python's iter function, produces a universal iterator / iterable, usable in Python and JavaScript\n        if (typeof iterable == 'string' || '__iter__' in iterable) {    // JavaScript Array or string or Python iterable (string has no 'in')\n            var result = iterable.__iter__ ();                          // Iterator has a __next__\n            result.next = __jsUsePyNext__;                              // Give it a next\n        }\n        else if ('selector' in iterable) {                              // Assume it's a JQuery iterator\n            var result = list (iterable) .__iter__ ();                  // Has a __next__\n            result.next = __jsUsePyNext__;                              // Give it a next\n        }\n        else if ('next' in iterable) {                                  // It's a JavaScript iterator already,  maybe a generator, has a next and may have a __next__\n            var result = iterable\n            if (! ('__next__' in result)) {                             // If there's no danger of recursion\n                result.__next__ = __pyUseJsNext__;                      // Give it a __next__\n            }\n        }\n        else if (Symbol.iterator in iterable) {                         // It's a JavaScript iterable such as a typed array, but not an iterator\n            var result = iterable [Symbol.iterator] ();                 // Has a next\n            result.__next__ = __pyUseJsNext__;                          // Give it a __next__\n        }\n        else {\n            throw IterableError (new Error ()); // No iterator at all\n        }\n        result [Symbol.iterator] = function () {return result;};\n        return result;\n    }\n\n    function py_next (iterator) {               // Called only in a Python context, could receive Python or JavaScript iterator\n        try {                                   // Primarily assume Python iterator, for max speed\n            var result = iterator.__next__ ();\n        }\n        catch (exception) {                     // JavaScript iterators are the exception here\n            var result = iterator.next ();\n            if (result.done) {\n                throw StopIteration (new Error ());\n            }\n            else {\n                return result.value;\n            }\n        }\n        if (result == undefined) {\n            throw StopIteration (new Error ());\n        }\n        else {\n            return result;\n        }\n    }\n\n    function __PyIterator__ (iterable) {\n        this.iterable = iterable;\n        this.index = 0;\n    }\n\n    __PyIterator__.prototype.__next__ = function () {\n        if (this.index < this.iterable.length) {\n            return this.iterable [this.index++];\n        }\n        else {\n            throw StopIteration (new Error ());\n        }\n    };\n\n    function __JsIterator__ (iterable) {\n        this.iterable = iterable;\n        this.index = 0;\n    }\n\n    __JsIterator__.prototype.next = function () {\n        if (this.index < this.iterable.py_keys.length) {\n            return {value: this.index++, done: false};\n        }\n        else {\n            return {value: undefined, done: true};\n        }\n    };\n\n    // END unified iterator model\n\n    // Reversed function for arrays\n    var py_reversed = function (iterable) {\n        iterable = iterable.slice ();\n        iterable.reverse ();\n        return iterable;\n    };\n    __all__.py_reversed = py_reversed;\n\n    // Zip method for arrays and strings\n    var zip = function () {\n        var args = [] .slice.call (arguments);\n        if (typeof args [0] == 'string') {\n            for (var i = 0; i < args.length; i++) {\n                args [i] = args [i] .split ('');\n            }\n        }\n        var shortest = args.length == 0 ? [] : args.reduce (    // Find shortest array in arguments\n            function (array0, array1) {\n                return array0.length < array1.length ? array0 : array1;\n            }\n        );\n        return shortest.map (                   // Map each element of shortest array\n            function (current, index) {         // To the result of this function\n                return args.map (               // Map each array in arguments\n                    function (current) {        // To the result of this function\n                        return current [index]; // Namely it's index't entry\n                    }\n                );\n            }\n        );\n    };\n    __all__.zip = zip;\n\n    // Range method, returning an array\n    function range (start, stop, step) {\n        if (stop == undefined) {\n            // one param defined\n            stop = start;\n            start = 0;\n        }\n        if (step == undefined) {\n            step = 1;\n        }\n        if ((step > 0 && start >= stop) || (step < 0 && start <= stop)) {\n            return [];\n        }\n        var result = [];\n        for (var i = start; step > 0 ? i < stop : i > stop; i += step) {\n            result.push(i);\n        }\n        return result;\n    };\n    __all__.range = range;\n\n    // Any, all and sum\n\n__pragma__ ('ifdef', '__esv6__')\n    function any (iterable) {\n        for (let item of iterable) {\n            if (bool (item)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    function all (iterable) {\n        for (let item of iterable) {\n            if (! bool (item)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    function sum (iterable) {\n        let result = 0;\n        for (let item of iterable) {\n            result += item;\n        }\n        return result;\n    }\n__pragma__ ('else')\n    function any (iterable) {\n        for (var index = 0; index < iterable.length; index++) {\n            if (bool (iterable [index])) {\n                return true;\n            }\n        }\n        return false;\n    }\n    function all (iterable) {\n        for (var index = 0; index < iterable.length; index++) {\n            if (! bool (iterable [index])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    function sum (iterable) {\n        var result = 0;\n        for (var index = 0; index < iterable.length; index++) {\n            result += iterable [index];\n        }\n        return result;\n    }\n__pragma__ ('endif')\n\n    __all__.any = any;\n    __all__.all = all;\n    __all__.sum = sum;\n\n    // Enumerate method, returning a zipped list\n    function enumerate (iterable) {\n        return zip (range (len (iterable)), iterable);\n    }\n    __all__.enumerate = enumerate;\n\n    // Shallow and deepcopy\n\n    function copy (anObject) {\n        if (anObject == null || typeof anObject == \"object\") {\n            return anObject;\n        }\n        else {\n            var result = {};\n            for (var attrib in obj) {\n                if (anObject.hasOwnProperty (attrib)) {\n                    result [attrib] = anObject [attrib];\n                }\n            }\n            return result;\n        }\n    }\n    __all__.copy = copy;\n\n    function deepcopy (anObject) {\n        if (anObject == null || typeof anObject == \"object\") {\n            return anObject;\n        }\n        else {\n            var result = {};\n            for (var attrib in obj) {\n                if (anObject.hasOwnProperty (attrib)) {\n                    result [attrib] = deepcopy (anObject [attrib]);\n                }\n            }\n            return result;\n        }\n    }\n    __all__.deepcopy = deepcopy;\n\n    // List extensions to Array\n\n    function list (iterable) {                                      // All such creators should be callable without new\n__pragma__ ('ifdef', '__esv6__')\n        var instance = iterable ? Array.from (iterable) : [];\n__pragma__ ('else')\n        var instance = iterable ? [] .slice.apply (iterable) : [];  // Spread iterable, n.b. array.slice (), so array before dot\n__pragma__ ('endif')\n        // Sort is the normal JavaScript sort, Python sort is a non-member function\n        return instance;\n    }\n    __all__.list = list;\n    Array.prototype.__class__ = list;   // All arrays are lists (not only if constructed by the list ctor), unless constructed otherwise\n    list.__name__ = 'list';\n\n    /*\n    Array.from = function (iterator) { // !!! remove\n        result = [];\n        for (item of iterator) {\n            result.push (item);\n        }\n        return result;\n    }\n    */\n\n    Array.prototype.__iter__ = function () {return new __PyIterator__ (this);};\n\n    Array.prototype.__getslice__ = function (start, stop, step) {\n        if (start < 0) {\n            start = this.length + start;\n        }\n\n        if (stop == null) {\n            stop = this.length;\n        }\n        else if (stop < 0) {\n            stop = this.length + stop;\n        }\n        else if (stop > this.length) {\n            stop = this.length;\n        }\n\n        var result = list ([]);\n        for (var index = start; index < stop; index += step) {\n            result.push (this [index]);\n        }\n\n        return result;\n    };\n\n    Array.prototype.__setslice__ = function (start, stop, step, source) {\n        if (start < 0) {\n            start = this.length + start;\n        }\n\n        if (stop == null) {\n            stop = this.length;\n        }\n        else if (stop < 0) {\n            stop = this.length + stop;\n        }\n\n        if (step == null) { // Assign to 'ordinary' slice, replace subsequence\n            Array.prototype.splice.apply (this, [start, stop - start] .concat (source));\n        }\n        else {              // Assign to extended slice, replace designated items one by one\n            var sourceIndex = 0;\n            for (var targetIndex = start; targetIndex < stop; targetIndex += step) {\n                this [targetIndex] = source [sourceIndex++];\n            }\n        }\n    };\n\n    Array.prototype.__repr__ = function () {\n        if (this.__class__ == set && !this.length) {\n            return 'set()';\n        }\n\n        var result = !this.__class__ || this.__class__ == list ? '[' : this.__class__ == tuple ? '(' : '{';\n\n        for (var index = 0; index < this.length; index++) {\n            if (index) {\n                result += ', ';\n            }\n            result += repr (this [index]);\n        }\n\n        if (this.__class__ == tuple && this.length == 1) {\n            result += ',';\n        }\n\n        result += !this.__class__ || this.__class__ == list ? ']' : this.__class__ == tuple ? ')' : '}';;\n        return result;\n    };\n\n    Array.prototype.__str__ = Array.prototype.__repr__;\n\n    Array.prototype.append = function (element) {\n        this.push (element);\n    };\n\n    Array.prototype.clear = function () {\n        this.length = 0;\n    };\n\n    Array.prototype.extend = function (aList) {\n        this.push.apply (this, aList);\n    };\n\n    Array.prototype.insert = function (index, element) {\n        this.splice (index, 0, element);\n    };\n\n    Array.prototype.remove = function (element) {\n        var index = this.indexOf (element);\n        if (index == -1) {\n            throw ValueError (new Error ());\n        }\n        this.splice (index, 1);\n    };\n\n    Array.prototype.index = function (element) {\n        return this.indexOf (element);\n    };\n\n    Array.prototype.py_pop = function (index) {\n        if (index == undefined) {\n            return this.pop ();  // Remove last element\n        }\n        else {\n            return this.splice (index, 1) [0];\n        }\n    };\n\n    Array.prototype.py_sort = function () {\n        __sort__.apply  (null, [this].concat ([] .slice.apply (arguments)));    // Can't work directly with arguments\n        // Python params: (iterable, key = None, reverse = False)\n        // py_sort is called with the Transcrypt kwargs mechanism, and just passes the params on to __sort__\n        // __sort__ is def'ed with the Transcrypt kwargs mechanism\n    };\n\n    Array.prototype.__add__ = function (aList) {\n        return list (this.concat (aList));\n    };\n\n    Array.prototype.__mul__ = function (scalar) {\n        var result = this;\n        for (var i = 1; i < scalar; i++) {\n            result = result.concat (this);\n        }\n        return result;\n    };\n\n    Array.prototype.__rmul__ = Array.prototype.__mul__;\n\n    // Tuple extensions to Array\n\n    function tuple (iterable) {\n        var instance = iterable ? [] .slice.apply (iterable) : [];\n        instance.__class__ = tuple; // Not all arrays are tuples\n        return instance;\n    }\n    __all__.tuple = tuple;\n    tuple.__name__ = 'tuple';\n\n    // Set extensions to Array\n    // N.B. Since sets are unordered, set operations will occasionally alter the 'this' array by sorting it\n\n    function set (iterable) {\n        var instance = [];\n        if (iterable) {\n            for (var index = 0; index < iterable.length; index++) {\n                instance.add (iterable [index]);\n            }\n\n\n        }\n        instance.__class__ = set;   // Not all arrays are sets\n        return instance;\n    }\n    __all__.set = set;\n    set.__name__ = 'set';\n\n    Array.prototype.__bindexOf__ = function (element) { // Used to turn O (n^2) into O (n log n)\n    // Since sorting is lex, compare has to be lex. This also allows for mixed lists\n\n        element += '';\n\n        var mindex = 0;\n        var maxdex = this.length - 1;\n\n        while (mindex <= maxdex) {\n            var index = (mindex + maxdex) / 2 | 0;\n            var middle = this [index] + '';\n\n            if (middle < element) {\n                mindex = index + 1;\n            }\n            else if (middle > element) {\n                maxdex = index - 1;\n            }\n            else {\n                return index;\n            }\n        }\n\n        return -1;\n    };\n\n    Array.prototype.add = function (element) {\n        if (this.indexOf (element) == -1) { // Avoid duplicates in set\n            this.push (element);\n        }\n    };\n\n    Array.prototype.discard = function (element) {\n        var index = this.indexOf (element);\n        if (index != -1) {\n            this.splice (index, 1);\n        }\n    };\n\n    Array.prototype.isdisjoint = function (other) {\n        this.sort ();\n        for (var i = 0; i < other.length; i++) {\n            if (this.__bindexOf__ (other [i]) != -1) {\n                return false;\n            }\n        }\n        return true;\n    };\n\n    Array.prototype.issuperset = function (other) {\n        this.sort ();\n        for (var i = 0; i < other.length; i++) {\n            if (this.__bindexOf__ (other [i]) == -1) {\n                return false;\n            }\n        }\n        return true;\n    };\n\n    Array.prototype.issubset = function (other) {\n        return set (other.slice ()) .issuperset (this); // Sort copy of 'other', not 'other' itself, since it may be an ordered sequence\n    };\n\n    Array.prototype.union = function (other) {\n        var result = set (this.slice () .sort ());\n        for (var i = 0; i < other.length; i++) {\n            if (result.__bindexOf__ (other [i]) == -1) {\n                result.push (other [i]);\n            }\n        }\n        return result;\n    };\n\n    Array.prototype.intersection = function (other) {\n        this.sort ();\n        var result = set ();\n        for (var i = 0; i < other.length; i++) {\n            if (this.__bindexOf__ (other [i]) != -1) {\n                result.push (other [i]);\n            }\n        }\n        return result;\n    };\n\n    Array.prototype.difference = function (other) {\n        var sother = set (other.slice () .sort ());\n        var result = set ();\n        for (var i = 0; i < this.length; i++) {\n            if (sother.__bindexOf__ (this [i]) == -1) {\n                result.push (this [i]);\n            }\n        }\n        return result;\n    };\n\n    Array.prototype.symmetric_difference = function (other) {\n        return this.union (other) .difference (this.intersection (other));\n    };\n\n    Array.prototype.py_update = function () {   // O (n)\n        var updated = [] .concat.apply (this.slice (), arguments) .sort ();\n        this.clear ();\n        for (var i = 0; i < updated.length; i++) {\n            if (updated [i] != updated [i - 1]) {\n                this.push (updated [i]);\n            }\n        }\n    };\n\n    Array.prototype.__eq__ = function (other) { // Also used for list\n        if (this.length != other.length) {\n            return false;\n        }\n        if (this.__class__ == set) {\n            this.sort ();\n            other.sort ();\n        }\n        for (var i = 0; i < this.length; i++) {\n            if (this [i] != other [i]) {\n                return false;\n            }\n        }\n        return true;\n    };\n\n    Array.prototype.__ne__ = function (other) { // Also used for list\n        return !this.__eq__ (other);\n    };\n\n    Array.prototype.__le__ = function (other) {\n        return this.issubset (other);\n    };\n\n    Array.prototype.__ge__ = function (other) {\n        return this.issuperset (other);\n    };\n\n    Array.prototype.__lt__ = function (other) {\n        return this.issubset (other) && !this.issuperset (other);\n    };\n\n    Array.prototype.__gt__ = function (other) {\n        return this.issuperset (other) && !this.issubset (other);\n    };\n\n    // String extensions\n\n    function str (stringable) {\n        try {\n            return stringable.__str__ ();\n        }\n        catch (exception) {\n            try {\n                return repr (stringable);\n            }\n            catch (exception) {\n                return String (stringable); // No new, so no permanent String object but a primitive in a temporary 'just in time' wrapper\n            }\n        }\n    };\n    __all__.str = str;\n\n    String.prototype.__class__ = str;   // All strings are str\n    str.__name__ = 'str';\n\n    String.prototype.__iter__ = function () {new __PyIterator__ (this);};\n\n    String.prototype.__repr__ = function () {\n        return (this.indexOf ('\\'') == -1 ? '\\'' + this + '\\'' : '\"' + this + '\"') .py_replace ('\\t', '\\\\t') .py_replace ('\\n', '\\\\n');\n    };\n\n    String.prototype.__str__ = function () {\n        return this;\n    };\n\n    String.prototype.capitalize = function () {\n        return this.charAt (0).toUpperCase () + this.slice (1);\n    };\n\n    String.prototype.endswith = function (suffix) {\n        return suffix == '' || this.slice (-suffix.length) == suffix;\n    };\n\n    String.prototype.find  = function (sub, start) {\n        return this.indexOf (sub, start);\n    };\n\n    String.prototype.__getslice__ = function (start, stop, step) {\n        if (start < 0) {\n            start = this.length + start;\n        }\n\n        if (stop == null) {\n            stop = this.length;\n        }\n        else if (stop < 0) {\n            stop = this.length + stop;\n        }\n\n        var result = '';\n        if (step == 1) {\n            result = this.substring (start, stop);\n        }\n        else {\n            for (var index = start; index < stop; index += step) {\n                result = result.concat (this.charAt(index));\n            }\n        }\n        return result;\n    }\n\n    // Since it's worthwhile for the 'format' function to be able to deal with *args, it is defined as a property\n    // __get__ will produce a bound function if there's something before the dot\n    // Since a call using *args is compiled to e.g. <object>.<function>.apply (null, args), the function has to be bound already\n    // Otherwise it will never be, because of the null argument\n    // Using 'this' rather than 'null' contradicts the requirement to be able to pass bound functions around\n    // The object 'before the dot' won't be available at call time in that case, unless implicitly via the function bound to it\n    // While for Python methods this mechanism is generated by the compiler, for JavaScript methods it has to be provided manually\n    // Call memoizing is unattractive here, since every string would then have to hold a reference to a bound format method\n    __setProperty__ (String.prototype, 'format', {\n        get: function () {return __get__ (this, function (self) {\n            var args = tuple ([] .slice.apply (arguments).slice (1));\n            var autoIndex = 0;\n            return self.replace (/\\{(\\w*)\\}/g, function (match, key) {\n                if (key == '') {\n                    key = autoIndex++;\n                }\n                if (key == +key) {  // So key is numerical\n                    return args [key] == undefined ? match : str (args [key]);\n                }\n                else {              // Key is a string\n                    for (var index = 0; index < args.length; index++) {\n                        // Find first 'dict' that has that key and the right field\n                        if (typeof args [index] == 'object' && args [index][key] != undefined) {\n                            return str (args [index][key]); // Return that field field\n                        }\n                    }\n                    return match;\n                }\n            });\n        });},\n        enumerable: true\n    });\n\n    String.prototype.isnumeric = function () {\n        return !isNaN (parseFloat (this)) && isFinite (this);\n    };\n\n    String.prototype.join = function (strings) {\n__pragma__ ('ifdef', '__esv6__')\n        strings = Array.from (strings); // Much faster than iterating through strings char by char\n__pragma__ ('endif')\n        return strings.join (this);\n    };\n\n    String.prototype.lower = function () {\n        return this.toLowerCase ();\n    };\n\n    String.prototype.py_replace = function (old, aNew, maxreplace) {\n        return this.split (old, maxreplace) .join (aNew);\n    };\n\n    String.prototype.lstrip = function () {\n        return this.replace (/^\\s*/g, '');\n    };\n\n    String.prototype.rfind = function (sub, start) {\n        return this.lastIndexOf (sub, start);\n    };\n\n    String.prototype.rsplit = function (sep, maxsplit) {    // Combination of general whitespace sep and positive maxsplit neither supported nor checked, expensive and rare\n        if (sep == undefined || sep == null) {\n            sep = /\\s+/;\n            var stripped = this.strip ();\n        }\n        else {\n            var stripped = this;\n        }\n\n        if (maxsplit == undefined || maxsplit == -1) {\n            return stripped.split (sep);\n        }\n        else {\n            var result = stripped.split (sep);\n            if (maxsplit < result.length) {\n                var maxrsplit = result.length - maxsplit;\n                return [result.slice (0, maxrsplit) .join (sep)] .concat (result.slice (maxrsplit));\n            }\n            else {\n                return result;\n            }\n        }\n    };\n\n    String.prototype.rstrip = function () {\n        return this.replace (/\\s*$/g, '');\n    };\n\n    String.prototype.py_split = function (sep, maxsplit) {  // Combination of general whitespace sep and positive maxsplit neither supported nor checked, expensive and rare\n        if (sep == undefined || sep == null) {\n            sep = /\\s+/;\n            var stripped = this.strip ();\n        }\n        else {\n            var stripped = this;\n        }\n\n        if (maxsplit == undefined || maxsplit == -1) {\n            return stripped.split (sep);\n        }\n        else {\n            var result = stripped.split (sep);\n            if (maxsplit < result.length) {\n                return result.slice (0, maxsplit).concat ([result.slice (maxsplit).join (sep)]);\n            }\n            else {\n                return result;\n            }\n        }\n    };\n\n    String.prototype.startswith = function (prefix) {\n        return this.indexOf (prefix) == 0;\n    };\n\n    String.prototype.strip = function () {\n        return this.trim ();\n    };\n\n    String.prototype.upper = function () {\n        return this.toUpperCase ();\n    };\n\n    String.prototype.__mul__ = function (scalar) {\n        var result = this;\n        for (var i = 1; i < scalar; i++) {\n            result = result + this;\n        }\n        return result;\n    };\n\n    String.prototype.__rmul__ = String.prototype.__mul__;\n\n    // Dict extensions to object\n\n    function __keys__ () {\n        var keys = [];\n        for (var attrib in this) {\n            if (!__specialattrib__ (attrib)) {\n                keys.push (attrib);\n            }\n        }\n        return keys;\n    }\n\n    function __items__ () {\n        var items = [];\n        for (var attrib in this) {\n            if (!__specialattrib__ (attrib)) {\n                items.push ([attrib, this [attrib]]);\n            }\n        }\n        return items;\n    }\n\n    function __del__ (key) {\n        delete this [key];\n    }\n\n    function __clear__ () {\n        for (var attrib in this) {\n            delete this [attrib];\n        }\n    }\n\n    function __getdefault__ (aKey, aDefault) {  // Each Python object already has a function called __get__, so we call this one __getdefault__\n        var result = this [aKey];\n        return result == undefined ? (aDefault == undefined ? null : aDefault) : result;\n    }\n\n    function __setdefault__ (aKey, aDefault) {\n        var result = this [aKey];\n        if (result != undefined) {\n            return result;\n        }\n        var val = aDefault == undefined ? null : aDefault;\n        this [aKey] = val;\n        return val;\n    }\n\n    function __pop__ (aKey, aDefault) {\n        var result = this [aKey];\n        if (result != undefined) {\n            delete this [aKey];\n            return result;\n        } else {\n            // Identify check because user could pass None\n            if ( aDefault === undefined ) {\n                throw KeyError (aKey, new Error());\n            }\n        }\n        return aDefault;\n    }\n    \n    function __popitem__ () {\n        var aKey = Object.keys (this) [0];\n        if (aKey == null) {\n            throw KeyError (aKey, new Error ());\n        }\n        var result = tuple ([aKey, this [aKey]]);\n        delete this [aKey];\n        return result;\n    }\n    \n    function __update__ (aDict) {\n        for (var aKey in aDict) {\n            this [aKey] = aDict [aKey];\n        }\n    }\n    \n    function __dgetitem__ (aKey) {\n        return this [aKey];\n    }\n    \n    function __dsetitem__ (aKey, aValue) {\n        this [aKey] = aValue;\n    }\n\n    function dict (objectOrPairs) {\n        var instance = {};\n        if (!objectOrPairs || objectOrPairs instanceof Array) { // It's undefined or an array of pairs\n            if (objectOrPairs) {\n                for (var index = 0; index < objectOrPairs.length; index++) {\n                    var pair = objectOrPairs [index];\n                    if ( !(pair instanceof Array) || pair.length != 2) {\n                        throw ValueError(\n                            \"dict update sequence element #\" + index +\n                            \" has length \" + pair.length +\n                            \"; 2 is required\", new Error());\n                    }\n                    var key = pair [0];\n                    var val = pair [1];\n                    if (!(objectOrPairs instanceof Array) && objectOrPairs instanceof Object) {\n                         // User can potentially pass in an object\n                         // that has a hierarchy of objects. This\n                         // checks to make sure that these objects\n                         // get converted to dict objects instead of\n                         // leaving them as js objects.\n                         \n                         if (!isinstance (objectOrPairs, dict)) {\n                             val = dict (val);\n                         }\n                    }\n                    instance [key] = val;\n                }\n            }\n        }\n        else {\n            if (isinstance (objectOrPairs, dict)) {\n                // Passed object is a dict already so we need to be a little careful\n                // N.B. - this is a shallow copy per python std - so\n                // it is assumed that children have already become\n                // python objects at some point.\n                \n                var aKeys = objectOrPairs.py_keys ();\n                for (var index = 0; index < aKeys.length; index++ ) {\n                    var key = aKeys [index];\n                    instance [key] = objectOrPairs [key];\n                }\n            } else if (objectOrPairs instanceof Object) {\n                // Passed object is a JavaScript object but not yet a dict, don't copy it\n                instance = objectOrPairs;\n            } else {\n                // We have already covered Array so this indicates\n                // that the passed object is not a js object - i.e.\n                // it is an int or a string, which is invalid.\n                \n                throw ValueError (\"Invalid type of object for dict creation\", new Error ());\n            }\n        }\n\n        // Trancrypt interprets e.g. {aKey: 'aValue'} as a Python dict literal rather than a JavaScript object literal\n        // So dict literals rather than bare Object literals will be passed to JavaScript libraries\n        // Some JavaScript libraries call all enumerable callable properties of an object that's passed to them\n        // So the properties of a dict should be non-enumerable\n        __setProperty__ (instance, '__class__', {value: dict, enumerable: false, writable: true});\n        __setProperty__ (instance, 'py_keys', {value: __keys__, enumerable: false});\n        __setProperty__ (instance, '__iter__', {value: function () {new __PyIterator__ (this.py_keys ());}, enumerable: false});\n        __setProperty__ (instance, Symbol.iterator, {value: function () {new __JsIterator__ (this.py_keys ());}, enumerable: false});\n        __setProperty__ (instance, 'py_items', {value: __items__, enumerable: false});\n        __setProperty__ (instance, 'py_del', {value: __del__, enumerable: false});\n        __setProperty__ (instance, 'py_clear', {value: __clear__, enumerable: false});\n        __setProperty__ (instance, 'py_get', {value: __getdefault__, enumerable: false});\n        __setProperty__ (instance, 'py_setdefault', {value: __setdefault__, enumerable: false});\n        __setProperty__ (instance, 'py_pop', {value: __pop__, enumerable: false});\n        __setProperty__ (instance, 'py_popitem', {value: __popitem__, enumerable: false});\n        __setProperty__ (instance, 'py_update', {value: __update__, enumerable: false});\n        __setProperty__ (instance, '__getitem__', {value: __dgetitem__, enumerable: false});    // Needed since compound keys necessarily\n        __setProperty__ (instance, '__setitem__', {value: __dsetitem__, enumerable: false});    // trigger overloading to deal with slices\n        return instance;\n    }\n\n    __all__.dict = dict;\n    dict.__name__ = 'dict';\n    \n    // Docstring setter\n\n    function __setdoc__ (docString) {\n        this.__doc__ = docString;\n        return this;\n    }\n\n    // Python classes, methods and functions are all translated to JavaScript functions\n    __setProperty__ (Function.prototype, '__setdoc__', {value: __setdoc__, enumerable: false});\n\n    // General operator overloading, only the ones that make most sense in matrix and complex operations\n\n    var __neg__ = function (a) {\n        if (typeof a == 'object' && '__neg__' in a) {\n            return a.__neg__ ();\n        }\n        else {\n            return -a;\n        }\n    };\n    __all__.__neg__ = __neg__;\n\n    var __matmul__ = function (a, b) {\n        return a.__matmul__ (b);\n    };\n    __all__.__matmul__ = __matmul__;\n\n    var __pow__ = function (a, b) {\n        if (typeof a == 'object' && '__pow__' in a) {\n            return a.__pow__ (b);\n        }\n        else if (typeof b == 'object' && '__rpow__' in b) {\n            return b.__rpow__ (a);\n        }\n        else {\n            return Math.pow (a, b);\n        }\n    };\n    __all__.pow = __pow__;\n\n    var __jsmod__ = function (a, b) {\n        if (typeof a == 'object' && '__mod__' in a) {\n            return a.__mod__ (b);\n        }\n        else if (typeof b == 'object' && '__rpow__' in b) {\n            return b.__rmod__ (a);\n        }\n        else {\n            return a % b;\n        }\n    };\n    __all__.__jsmod__ = __jsmod__;\n    \n    var __mod__ = function (a, b) {\n        if (typeof a == 'object' && '__mod__' in a) {\n            return a.__mod__ (b);\n        }\n        else if (typeof b == 'object' && '__rpow__' in b) {\n            return b.__rmod__ (a);\n        }\n        else {\n            return ((a % b) + b) % b;\n        }\n    };\n    __all__.mod = __mod__;\n\n    // Overloaded binary arithmetic\n    \n    var __mul__ = function (a, b) {\n        if (typeof a == 'object' && '__mul__' in a) {\n            return a.__mul__ (b);\n        }\n        else if (typeof b == 'object' && '__rmul__' in b) {\n            return b.__rmul__ (a);\n        }\n        else if (typeof a == 'string') {\n            return a.__mul__ (b);\n        }\n        else if (typeof b == 'string') {\n            return b.__rmul__ (a);\n        }\n        else {\n            return a * b;\n        }\n    };\n    __all__.__mul__ = __mul__;\n\n    var __div__ = function (a, b) {\n        if (typeof a == 'object' && '__div__' in a) {\n            return a.__div__ (b);\n        }\n        else if (typeof b == 'object' && '__rdiv__' in b) {\n            return b.__rdiv__ (a);\n        }\n        else {\n            return a / b;\n        }\n    };\n    __all__.__div__ = __div__;\n\n    var __add__ = function (a, b) {\n        if (typeof a == 'object' && '__add__' in a) {\n            return a.__add__ (b);\n        }\n        else if (typeof b == 'object' && '__radd__' in b) {\n            return b.__radd__ (a);\n        }\n        else {\n            return a + b;\n        }\n    };\n    __all__.__add__ = __add__;\n\n    var __sub__ = function (a, b) {\n        if (typeof a == 'object' && '__sub__' in a) {\n            return a.__sub__ (b);\n        }\n        else if (typeof b == 'object' && '__rsub__' in b) {\n            return b.__rsub__ (a);\n        }\n        else {\n            return a - b;\n        }\n    };\n    __all__.__sub__ = __sub__;\n\n    // Overloaded binary bitwise\n    \n    var __lshift__ = function (a, b) {\n        if (typeof a == 'object' && '__lshift__' in a) {\n            return a.__lshift__ (b);\n        }\n        else if (typeof b == 'object' && '__rlshift__' in b) {\n            return b.__rlshift__ (a);\n        }\n        else {\n            return a << b;\n        }\n    };\n    __all__.__lshift__ = __lshift__;\n\n    var __rshift__ = function (a, b) {\n        if (typeof a == 'object' && '__rshift__' in a) {\n            return a.__rshift__ (b);\n        }\n        else if (typeof b == 'object' && '__rrshift__' in b) {\n            return b.__rrshift__ (a);\n        }\n        else {\n            return a >> b;\n        }\n    };\n    __all__.__rshift__ = __rshift__;\n\n    var __or__ = function (a, b) {\n        if (typeof a == 'object' && '__or__' in a) {\n            return a.__or__ (b);\n        }\n        else if (typeof b == 'object' && '__ror__' in b) {\n            return b.__ror__ (a);\n        }\n        else {\n            return a | b;\n        }\n    };\n    __all__.__or__ = __or__;\n\n    var __xor__ = function (a, b) {\n        if (typeof a == 'object' && '__xor__' in a) {\n            return a.__xor__ (b);\n        }\n        else if (typeof b == 'object' && '__rxor__' in b) {\n            return b.__rxor__ (a);\n        }\n        else {\n            return a ^ b;\n        }\n    };\n    __all__.__xor__ = __xor__;\n\n    var __and__ = function (a, b) {\n        if (typeof a == 'object' && '__and__' in a) {\n            return a.__and__ (b);\n        }\n        else if (typeof b == 'object' && '__rand__' in b) {\n            return b.__rand__ (a);\n        }\n        else {\n            return a & b;\n        }\n    };\n    __all__.__and__ = __and__;    \n        \n    // Overloaded binary compare\n    \n    var __eq__ = function (a, b) {\n        if (typeof a == 'object' && '__eq__' in a) {\n            return a.__eq__ (b);\n        }\n        else {\n            return a == b;\n        }\n    };\n    __all__.__eq__ = __eq__;\n\n    var __ne__ = function (a, b) {\n        if (typeof a == 'object' && '__ne__' in a) {\n            return a.__ne__ (b);\n        }\n        else {\n            return a != b\n        }\n    };\n    __all__.__ne__ = __ne__;\n\n    var __lt__ = function (a, b) {\n        if (typeof a == 'object' && '__lt__' in a) {\n            return a.__lt__ (b);\n        }\n        else {\n            return a < b;\n        }\n    };\n    __all__.__lt__ = __lt__;\n\n    var __le__ = function (a, b) {\n        if (typeof a == 'object' && '__le__' in a) {\n            return a.__le__ (b);\n        }\n        else {\n            return a <= b;\n        }\n    };\n    __all__.__le__ = __le__;\n\n    var __gt__ = function (a, b) {\n        if (typeof a == 'object' && '__gt__' in a) {\n            return a.__gt__ (b);\n        }\n        else {\n            return a > b;\n        }\n    };\n    __all__.__gt__ = __gt__;\n\n    var __ge__ = function (a, b) {\n        if (typeof a == 'object' && '__ge__' in a) {\n            return a.__ge__ (b);\n        }\n        else {\n            return a >= b;\n        }\n    };\n    __all__.__ge__ = __ge__;\n    \n    // Overloaded augmented general\n    \n    var __imatmul__ = function (a, b) {\n        if ('__imatmul__' in a) {\n            return a.__imatmul__ (b);\n        }\n        else {\n            return a.__matmul__ (b);\n        }\n    };\n    __all__.__imatmul__ = __imatmul__;\n\n    var __ipow__ = function (a, b) {\n        if (typeof a == 'object' && '__pow__' in a) {\n            return a.__ipow__ (b);\n        }\n        else if (typeof a == 'object' && '__ipow__' in a) {\n            return a.__pow__ (b);\n        }\n        else if (typeof b == 'object' && '__rpow__' in b) {\n            return b.__rpow__ (a);\n        }\n        else {\n            return Math.pow (a, b);\n        }\n    };\n    __all__.ipow = __ipow__;\n\n    var __ijsmod__ = function (a, b) {\n        if (typeof a == 'object' && '__imod__' in a) {\n            return a.__ismod__ (b);\n        }\n        else if (typeof a == 'object' && '__mod__' in a) {\n            return a.__mod__ (b);\n        }\n        else if (typeof b == 'object' && '__rpow__' in b) {\n            return b.__rmod__ (a);\n        }\n        else {\n            return a % b;\n        }\n    };\n    __all__.ijsmod__ = __ijsmod__;\n    \n    var __imod__ = function (a, b) {\n        if (typeof a == 'object' && '__imod__' in a) {\n            return a.__imod__ (b);\n        }\n        else if (typeof a == 'object' && '__mod__' in a) {\n            return a.__mod__ (b);\n        }\n        else if (typeof b == 'object' && '__rpow__' in b) {\n            return b.__rmod__ (a);\n        }\n        else {\n            return ((a % b) + b) % b;\n        }\n    };\n    __all__.imod = __imod__;\n    \n    // Overloaded augmented arithmetic\n    \n    var __imul__ = function (a, b) {\n        if (typeof a == 'object' && '__imul__' in a) {\n            return a.__imul__ (b);\n        }\n        else if (typeof a == 'object' && '__mul__' in a) {\n            return a = a.__mul__ (b);\n        }\n        else if (typeof b == 'object' && '__rmul__' in b) {\n            return a = b.__rmul__ (a);\n        }\n        else if (typeof a == 'string') {\n            return a = a.__mul__ (b);\n        }\n        else if (typeof b == 'string') {\n            return a = b.__rmul__ (a);\n        }\n        else {\n            return a *= b;\n        }\n    };\n    __all__.__imul__ = __imul__;\n\n    var __idiv__ = function (a, b) {\n        if (typeof a == 'object' && '__idiv__' in a) {\n            return a.__idiv__ (b);\n        }\n        else if (typeof a == 'object' && '__div__' in a) {\n            return a = a.__div__ (b);\n        }\n        else if (typeof b == 'object' && '__rdiv__' in b) {\n            return a = b.__rdiv__ (a);\n        }\n        else {\n            return a /= b;\n        }\n    };\n    __all__.__idiv__ = __idiv__;\n\n    var __iadd__ = function (a, b) {\n        if (typeof a == 'object' && '__iadd__' in a) {\n            return a.__iadd__ (b);\n        }\n        else if (typeof a == 'object' && '__add__' in a) {\n            return a = a.__add__ (b);\n        }\n        else if (typeof b == 'object' && '__radd__' in b) {\n            return a = b.__radd__ (a);\n        }\n        else {\n            return a += b;\n        }\n    };\n    __all__.__iadd__ = __iadd__;\n\n    var __isub__ = function (a, b) {\n        if (typeof a == 'object' && '__isub__' in a) {\n            return a.__isub__ (b);\n        }\n        else if (typeof a == 'object' && '__sub__' in a) {\n            return a = a.__sub__ (b);\n        }\n        else if (typeof b == 'object' && '__rsub__' in b) {\n            return a = b.__rsub__ (a);\n        }\n        else {\n            return a -= b;\n        }\n    };\n    __all__.__isub__ = __isub__;\n\n    // Overloaded augmented bitwise\n    \n    var __ilshift__ = function (a, b) {\n        if (typeof a == 'object' && '__ilshift__' in a) {\n            return a.__ilshift__ (b);\n        }\n        else if (typeof a == 'object' && '__lshift__' in a) {\n            return a = a.__lshift__ (b);\n        }\n        else if (typeof b == 'object' && '__rlshift__' in b) {\n            return a = b.__rlshift__ (a);\n        }\n        else {\n            return a <<= b;\n        }\n    };\n    __all__.__ilshift__ = __ilshift__;\n\n    var __irshift__ = function (a, b) {\n        if (typeof a == 'object' && '__irshift__' in a) {\n            return a.__irshift__ (b);\n        }\n        else if (typeof a == 'object' && '__rshift__' in a) {\n            return a = a.__rshift__ (b);\n        }\n        else if (typeof b == 'object' && '__rrshift__' in b) {\n            return a = b.__rrshift__ (a);\n        }\n        else {\n            return a >>= b;\n        }\n    };\n    __all__.__irshift__ = __irshift__;\n\n    var __ior__ = function (a, b) {\n        if (typeof a == 'object' && '__ior__' in a) {\n            return a.__ior__ (b);\n        }\n        else if (typeof a == 'object' && '__or__' in a) {\n            return a = a.__or__ (b);\n        }\n        else if (typeof b == 'object' && '__ror__' in b) {\n            return a = b.__ror__ (a);\n        }\n        else {\n            return a |= b;\n        }\n    };\n    __all__.__ior__ = __ior__;\n\n    var __ixor__ = function (a, b) {\n        if (typeof a == 'object' && '__ixor__' in a) {\n            return a.__ixor__ (b);\n        }\n        else if (typeof a == 'object' && '__xor__' in a) {\n            return a = a.__xor__ (b);\n        }\n        else if (typeof b == 'object' && '__rxor__' in b) {\n            return a = b.__rxor__ (a);\n        }\n        else {\n            return a ^= b;\n        }\n    };\n    __all__.__ixor__ = __ixor__;\n\n    var __iand__ = function (a, b) {\n        if (typeof a == 'object' && '__iand__' in a) {\n            return a.__iand__ (b);\n        }\n        else if (typeof a == 'object' && '__and__' in a) {\n            return a = a.__and__ (b);\n        }\n        else if (typeof b == 'object' && '__rand__' in b) {\n            return a = b.__rand__ (a);\n        }\n        else {\n            return a &= b;\n        }\n    };\n    __all__.__iand__ = __iand__;\n    \n    // Indices and slices\n\n    var __getitem__ = function (container, key) {                           // Slice c.q. index, direct generated call to runtime switch\n        if (typeof container == 'object' && '__getitem__' in container) {\n            return container.__getitem__ (key);                             // Overloaded on container\n        }\n        else {\n            return container [key];                                         // Container must support bare JavaScript brackets\n        }\n    };\n    __all__.__getitem__ = __getitem__;\n\n    var __setitem__ = function (container, key, value) {                    // Slice c.q. index, direct generated call to runtime switch\n        if (typeof container == 'object' && '__setitem__' in container) {\n            container.__setitem__ (key, value);                             // Overloaded on container\n        }\n        else {\n            container [key] = value;                                        // Container must support bare JavaScript brackets\n        }\n    };\n    __all__.__setitem__ = __setitem__;\n\n    var __getslice__ = function (container, lower, upper, step) {           // Slice only, no index, direct generated call to runtime switch\n        if (typeof container == 'object' && '__getitem__' in container) {\n            return container.__getitem__ ([lower, upper, step]);            // Container supports overloaded slicing c.q. indexing\n        }\n        else {\n            return container.__getslice__ (lower, upper, step);             // Container only supports slicing injected natively in prototype\n        }\n    };\n    __all__.__getslice__ = __getslice__;\n\n    var __setslice__ = function (container, lower, upper, step, value) {    // Slice, no index, direct generated call to runtime switch\n        if (typeof container == 'object' && '__setitem__' in container) {\n            container.__setitem__ ([lower, upper, step], value);            // Container supports overloaded slicing c.q. indexing\n        }\n        else {\n            container.__setslice__ (lower, upper, step, value);             // Container only supports slicing injected natively in prototype\n        }\n    };\n    __all__.__setslice__ = __setslice__;\n\n",
		"import logging\n\nlogger = logging.getLogger('root')\n\ndef load(player_element, sourcefile):\n    try:\n        audio_element = document.getElementById(player_element)\n\n        if not len(audio_element):\n            raise Exception(\"unable to load audio from element '{}'\".format(player_element))\n\n        if len(sourcefile):\n            audio_element.src = sourcefile\n        return audio_element\n\n    except Exception as e:\n        logging.exception(e)\n\ndef clip(filename):\n    player = __new__(Audio(filename))\n    return player\n\ndef loop(filename):\n\n    player = __new__(Audio(filename))\n    def reset_player():\n        player.currentTime = 0\n        player.play()\n    player.addEventListener('ended', reset_player, False)\n\n    return player",
		"from utils import clamp\n\nclass Keyboard:\n    def __init__(self):\n        self.keyboard = {0: False}\n        self.handlers = {}\n\n    def key_down(self, key):\n        self.keyboard[key.key] = True\n\n    def key_up(self, key):\n        self.keyboard[key.key] = False\n\n    def get(self, key):\n        return self.keyboard.get(key, False)\n\n    def get_axis(self, key):\n        return self.handlers[key].value\n\n    def add_handler(self, name, handler):\n        self.handlers[name] = handler\n\n    def update(self, interval):\n        for _, eachhandler in self.handlers.items():\n            eachhandler.update(self, interval)\n\n    def clear(self, axis):\n        self.handlers.get(axis).value = 0\n\n\nclass ControlAxis:\n    __pragma__('kwargs')\n\n    def __init__(self, positive_key: str, negative_key: str, attack=1, decay=0, deadzone=0.02):\n        self.positive = positive_key\n        self.negative = negative_key\n        self.attack = attack\n        self.decay = decay\n        self.deadzone = deadzone\n        self.value = 0\n\n    __pragma__('nokwargs')\n\n    def update(self, keyboard: Keyboard, interval: float):\n        self.value -= (interval * self.decay * self.value)\n        dz = abs(self.value) < self.deadzone\n        if keyboard.get(self.positive):\n            dz = False\n            self.value += interval * self.attack\n        if keyboard.get(self.negative):\n            dz = False\n            self.value -= interval * self.attack\n\n        if dz:\n            self.value = 0\n        else:\n            self.value = clamp(self.value, -1, 1)\n",
		"# Copyright 2001-2016 by Vinay Sajip. All Rights Reserved.\n#\n# Permission to use, copy, modify, and distribute this software and its\n# documentation for any purpose and without fee is hereby granted,\n# provided that the above copyright notice appear in all copies and that\n# both that copyright notice and this permission notice appear in\n# supporting documentation, and that the name of Vinay Sajip\n# not be used in advertising or publicity pertaining to distribution\n# of the software without specific, written prior permission.\n# VINAY SAJIP DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING\n# ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL\n# VINAY SAJIP BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR\n# ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER\n# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT\n# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n#\n# Updated for Transcrypt by Carl Allendorph 2016\n\n\"\"\"\nLogging package for Python. Based on PEP 282 and comments thereto in\ncomp.lang.python.\n\nCopyright (C) 2001-2016 Vinay Sajip. All Rights Reserved.\n\nTo use, simply 'import logging' and log away!\n\nEdited By Carl Allendorph 2016 for the Transcrypt Project\n\nThis code base was originally pulled from the Python project to\nmaintain as much compatibility in the interfaces as possible.\n\nLimitations:\n- The output formatting is currently limited to string.format() style\n    formatting because of Transcrypt. This means that PercentStyle\n    formatting and string template formatting is disabled and not\n    available.\n- I've had to makes some hacks to work around shortcomings in Transcrypt\n    at this point but most of these are superficial.\n- The components of the logging dealing with exceptions, stack traces,\n    and other content are not implemented at this point\n- Anything related to threads and processes is set to default values\n    of None.\n- StreamHandler publishes content to console.log as sys.stderr is not\n    available.\n- Integration with the `warnings` python module is not implemented because\n    `warnings` does not exist yet.\n\nAutomated tests are available in the logging test module.\n\n\"\"\"\nfrom org.transcrypt.stubs.browser import __pragma__\nimport time\nimport warnings\n\n__author__  = \"Vinay Sajip <vinay_sajip@red-dove.com>, Carl Allendorph\"\n__status__  = \"experimental\"\n# The following module attributes are no longer updated.\n__version__ = \"0.5.1.2\"\n__date__    = \"15 November 2016\"\n\n#---------------------------------------------------------------------------\n#       Miscellaneous module data\n#---------------------------------------------------------------------------\n\n#\n#_startTime is used as the base when calculating the relative time of events\n#\n_startTime = time.time()\n\n#\n#raiseExceptions is used to see if exceptions during handling should be\n#propagated\n#\nraiseExceptions = True\n\n#\n# If you don't want threading information in the log, set this to zero\n#\n# @note - This currently doesn't do anything in transcrypt because there\n#       is no logging facility. I've left it here for compatiblity\nlogThreads = True\n\n#\n# If you don't want multiprocessing information in the log, set this to zero\n#\n# @note - This currently doesn't do anything in transcrypt because there\n#       is no multiprocessing facility. I've left it here for compatiblity\nlogMultiprocessing = True\n\n#\n# If you don't want process information in the log, set this to zero\n#\n# @note - This currently doesn't do anything in transcrypt because there\n#       is no separate process facility. I've left it here for compatiblity\nlogProcesses = True\n\n#---------------------------------------------------------------------------\n#       Level related stuff\n#---------------------------------------------------------------------------\n#\n# Default levels and level names, these can be replaced with any positive set\n# of values having corresponding names. There is a pseudo-level, NOTSET, which\n# is only really there as a lower limit for user-defined levels. Handlers and\n# loggers are initialized with NOTSET so that they will log all messages, even\n# at user-defined levels.\n#\n\nCRITICAL = 50\nFATAL = CRITICAL\nERROR = 40\nWARNING = 30\nWARN = WARNING\nINFO = 20\nDEBUG = 10\nNOTSET = 0\n\n_levelToName = {\n    CRITICAL: 'CRITICAL',\n    ERROR: 'ERROR',\n    WARNING: 'WARNING',\n    INFO: 'INFO',\n    DEBUG: 'DEBUG',\n    NOTSET: 'NOTSET',\n}\n_nameToLevel = {\n    'CRITICAL': CRITICAL,\n    'FATAL': FATAL,\n    'ERROR': ERROR,\n    'WARN': WARNING,\n    'WARNING': WARNING,\n    'INFO': INFO,\n    'DEBUG': DEBUG,\n    'NOTSET': NOTSET,\n}\n\ndef getLevelName(level):\n    \"\"\"\n    Return the textual representation of logging level 'level'.\n\n    If the level is one of the predefined levels (CRITICAL, ERROR, WARNING,\n    INFO, DEBUG) then you get the corresponding string. If you have\n    associated levels with names using addLevelName then the name you have\n    associated with 'level' is returned.\n\n    If a numeric value corresponding to one of the defined levels is passed\n    in, the corresponding string representation is returned.\n\n    Otherwise, the string \"Level %s\" % level is returned.\n    \"\"\"\n    # See Issues #22386 and #27937 for why it's this way\n    return (_levelToName.get(level) or _nameToLevel.get(level) or\n                    \"Level {}\".format(level) )\n\ndef addLevelName(level, levelName):\n    \"\"\"\n    Associate 'levelName' with 'level'.\n\n    This is used when converting levels to text during message formatting.\n    \"\"\"\n    _acquireLock()\n    try:        #unlikely to cause an exception, but you never know...\n        _levelToName[level] = levelName\n        _nameToLevel[levelName] = level\n    except Exception as exc: # @note - this is a hack around bug in transcrypt\n        raise exc\n    finally:\n        _releaseLock()\n\n# @note - We currently don't have this functionality\n#        but it could be added in the future because the\n#        javascript stack is available in exception. Matching this\n#        to the python info will be difficult though.\n# if hasattr(sys, '_getframe'):\n#           currentframe = lambda: sys._getframe(3)\n# else: #pragma: no cover\n#           def currentframe():\n#                   \"\"\"Return the frame object for the caller's stack frame.\"\"\"\n#                   try:\n#                           raise Exception\n#                   except Exception:\n#                           return sys.exc_info()[2].tb_frame.f_back\n\ndef currentframe():\n    return(None)\n\n#\n# _srcfile is used when walking the stack to check when we've got the first\n# caller stack frame, by skipping frames whose filename is that of this\n# module's source. It therefore should contain the filename of this module's\n# source file.\n#\n# Ordinarily we would use __file__ for this, but frozen modules don't always\n# have __file__ set, for some reason (see Issue #21736). Thus, we get the\n# filename from a handy code object from a function defined in this module.\n# (There's no particular reason for picking addLevelName.)\n#\n\n# @note - this is not going to work\n#_srcfile = os.path.normcase(addLevelName.__code__.co_filename)\n\n# _srcfile is only used in conjunction with sys._getframe().\n# To provide compatibility with older versions of Python, set _srcfile\n# to None if _getframe() is not available; this value will prevent\n# findCaller() from being called. You can also do this if you want to avoid\n# the overhead of fetching caller information, even when _getframe() is\n# available.\n#if not hasattr(sys, '_getframe'):\n#        _srcfile = None\n\n_srcfile = None\n\ndef _checkLevel(level):\n    if isinstance(level, int):\n        rv = level\n    elif str(level) == level:\n        if level not in _nameToLevel:\n            raise ValueError(\"Unknown level: {}\".format(level))\n        rv = _nameToLevel[level]\n    else:\n        raise TypeError(\"Level not an integer or a valid string: {}\".format(level))\n    return rv\n\n#---------------------------------------------------------------------------\n#       Thread-related stuff\n#---------------------------------------------------------------------------\n\n#\n#_lock is used to serialize access to shared data structures in this module.\n#This needs to be an RLock because fileConfig() creates and configures\n#Handlers, and so might arbitrary user threads. Since Handler code updates the\n#shared dictionary _handlers, it needs to acquire the lock. But if configuring,\n#the lock would already have been acquired - so we need an RLock.\n#The same argument applies to Loggers and Manager.loggerDict.\n#\n#if threading:\n#        _lock = threading.RLock()\n#else: #pragma: no cover\n\n# There is no Threading Module so we will disable this by default\n# @note future optimization - remove lock methods altogether.\n_lock = None\n\n# @note I've left the a acquire/release methods in case there\n#   is a case in the future where a web worker background thread\n#   might be available\ndef _acquireLock():\n    \"\"\"\n    Acquire the module-level lock for serializing access to shared data.\n\n    This should be released with _releaseLock().\n    \"\"\"\n    if _lock:\n        _lock.acquire()\n\ndef _releaseLock():\n    \"\"\"\n    Release the module-level lock acquired by calling _acquireLock().\n    \"\"\"\n    if _lock:\n        _lock.release()\n\n#---------------------------------------------------------------------------\n#       The logging record\n#---------------------------------------------------------------------------\n\nclass LogRecord(object):\n    \"\"\"\n    A LogRecord instance represents an event being logged.\n\n    LogRecord instances are created every time something is logged. They\n    contain all the information pertinent to the event being logged. The\n    main information passed in is in msg and args, which are combined\n    using str(msg) % args to create the message field of the record. The\n    record also includes information such as when the record was created,\n    the source line where the logging call was made, and any exception\n    information to be logged.\n    \"\"\"\n    def __init__(self, name, level, pathname, lineno,\n                             msg, args, exc_info, func=None, sinfo=None, **kwargs):\n        \"\"\"\n        Initialize a logging record with interesting information.\n        \"\"\"\n        ct = time.time()\n        self.name = name\n        self.msg = msg\n        #\n        # The following statement allows passing of a dictionary as a sole\n        # argument, so that you can do something like\n        #    logging.debug(\"a %(a)d b %(b)s\", {'a':1, 'b':2})\n        # Suggested by Stefan Behnel.\n        # Note that without the test for args[0], we get a problem because\n        # during formatting, we test to see if the arg is present using\n        # 'if self.args:'. If the event being logged is e.g. 'Value is %d'\n        # and if the passed arg fails 'if self.args:' then no formatting\n        # is done. For example, logger.warning('Value is %d', 0) would log\n        # 'Value is %d' instead of 'Value is 0'.\n        # For the use case of passing a dictionary, this should not be a\n        # problem.\n        # Issue #21172: a request was made to relax the isinstance check\n        # to hasattr(args[0], '__getitem__'). However, the docs on string\n        # formatting still seem to suggest a mapping object is required.\n        # Thus, while not removing the isinstance check, it does now look\n        # for collections.Mapping rather than, as before, dict.\n\n\n        if (args and len(args) == 1 and isinstance(args[0], collections.Mapping)\n                and args[0]):\n            # @note - we can't manage these kind of logging args\n            #       so we don't try\n            #args = args[0]\n            if ( raiseExceptions ):\n                raise NotImplementedError(\"No Dict Args to Log Record\")\n\n        self.args = args\n        self.levelname = getLevelName(level)\n        self.levelno = level\n        self.pathname = pathname\n        # @note - currently we don't have os.path\n        #       so we are going to ignore this\n        # try:\n        #           self.filename = os.path.basename(pathname)\n        #           self.module = os.path.splitext(self.filename)[0]\n        # except (TypeError, ValueError, AttributeError):\n        #           self.filename = pathname\n        #           self.module = \"Unknown module\"\n        self.filename = pathname\n        self.module = \"Unknown module\"\n\n        self.exc_info = exc_info\n        self.exc_text = None            # used to cache the traceback text\n        self.stack_info = sinfo\n        self.lineno = lineno\n        self.funcName = func\n        self.created = ct\n        self.msecs = (ct - int(ct)) * 1000\n        self.relativeCreated = (self.created - _startTime) * 1000\n        # @note - We have no threading interface so we are going\n        #        to set default values here to prevent bad behavior\n        # if logThreads and threading:\n        #           self.thread = threading.get_ident()\n        #           self.threadName = threading.current_thread().name\n        # else: # pragma: no cover\n        #           self.thread = None\n        #           self.threadName = None\n        self.thread = None\n        self.threadName = None\n\n        # @note - No Multiprocessing - we will err on the\n        #        side of caution\n        # if not logMultiprocessing: # pragma: no cover\n        #           self.processName = None\n        # else:\n        #           self.processName = 'MainProcess'\n        #           mp = sys.modules.get('multiprocessing')\n        #           if mp is not None:\n        #                   # Errors may occur if multiprocessing has not finished loading\n        #                   # yet - e.g. if a custom import hook causes third-party code\n        #                   # to run when multiprocessing calls import. See issue 8200\n        #                   # for an example\n        #                   try:\n        #                           self.processName = mp.current_process().name\n        #                   except Exception: #pragma: no cover\n        #                           pass\n        self.processName = None\n\n        # if logProcesses and hasattr(os, 'getpid'):\n        #           self.process = os.getpid()\n        # else:\n        #           self.process = None\n        self.process = None\n\n    def getMessage(self):\n        \"\"\"\n        Return the message for this LogRecord.\n\n        Return the message for this LogRecord after merging any\n        user-supplied arguments with the message.\n        \"\"\"\n        msg = str(self.msg)\n        if self.args:\n            msg = msg.format(*self.args)\n        return msg\n\n    def toDict(self):\n        \"\"\" Utility method to convert the LogRecord object into a\n        an object that can be passed to the str.format function.\n        This is needed to allow for named string format arguments.\n        @note - if you create a new LogRecord object type, then\n           you will likely want to override this method to add\n           more keys to the returned dict\n        \"\"\"\n        keysToPick=[\n            \"name\", \"msg\", \"levelname\", \"levelno\", \"pathname\",\n            \"filename\", \"module\", \"lineno\", \"funcName\", \"created\",\n            \"asctime\", \"msecs\", \"relativeCreated\", \"thread\", \"threadName\",\n            \"process\"\n            ]\n\n        ret = {}\n        for k in keysToPick:\n            if ( k == \"name\" ):\n                # This is a hack - name seems to be owned by the\n                # class -- and evals to \"cls\" and the key \"name\" gets\n                # replaced by the key \"py_name\" in javascript\n                ret[k] = getattr(self, \"py_name\", None)\n            else:\n                ret[k] = getattr(self, k, None)\n        ret[\"message\"] = self.getMessage()\n        return(ret)\n\n\n    def __str__(self):\n        return '<LogRecord: {}, {}, {}, {}, \"{}\">'.format(\n            self.name, self.levelno,\n            self.pathname, self.lineno, self.msg)\n\n    def __repr__(self):\n        return(str(self))\n\n\n#\n#       Determine which class to use when instantiating log records.\n#\n_logRecordFactory = LogRecord\n\ndef setLogRecordFactory(factory):\n    \"\"\"\n    Set the factory to be used when instantiating a log record.\n\n    :param factory: A callable which will be called to instantiate\n    a log record.\n    \"\"\"\n    global _logRecordFactory\n    _logRecordFactory = factory\n\ndef getLogRecordFactory():\n    \"\"\"\n    Return the factory to be used when instantiating a log record.\n    \"\"\"\n\n    return _logRecordFactory\n\ndef makeLogRecord(dict):\n    \"\"\"\n    Make a LogRecord whose attributes are defined by the specified dictionary,\n    This function is useful for converting a logging event received over\n    a socket connection (which is sent as a dictionary) into a LogRecord\n    instance.\n    \"\"\"\n    rv = _logRecordFactory(None, None, \"\", 0, \"\", (), None, None)\n    rv.__dict__.update(dict)\n    return rv\n\n#---------------------------------------------------------------------------\n#       Formatter classes and functions\n#---------------------------------------------------------------------------\n\n# @note - this requires string.Template which we need\n#        to confirm is available - the % operator I don't think is\n#        implemented for strings in transcrypt at this point.\nclass PercentStyle(object):\n    default_format = '%(message)s'\n    asctime_format = '%(asctime)s'\n    asctime_search = '%(asctime)'\n\n    def __init__(self, fmt):\n        self._fmt = fmt or self.default_format\n\n    def usesTime(self):\n        return self._fmt.find(self.asctime_search) >= 0\n\n    def format(self, record):\n        return self._fmt % record.__dict__\n\n### I think we are going to have to restrict to use this\n#    type unless we can find the other is available\nclass StrFormatStyle(PercentStyle):\n    default_format = '{message}'\n    asctime_format = '{asctime}'\n    asctime_search = '{asctime' # @question is this right ?\n\n    __pragma__('kwargs')\n    def format(self, record):\n\n        return self._fmt.format(**(record.toDict()))\n    __pragma__('nokwargs')\n\n# Again - I don't think we have the implementation for this type\n#        yet.\nclass StringTemplateStyle(PercentStyle):\n    default_format = '${message}'\n    asctime_format = '${asctime}'\n    asctime_search = '${asctime}'\n\n    def __init__(self, fmt):\n        self._fmt = fmt or self.default_format\n        self._tpl = Template(self._fmt)\n\n    def usesTime(self):\n        fmt = self._fmt\n        return fmt.find('$asctime') >= 0 or fmt.find(self.asctime_format) >= 0\n\n    __pragma__('kwargs')\n    def format(self, record):\n        return self._tpl.substitute(**record.__dict__)\n    __pragma__('nokwargs')\n\nBASIC_FORMAT = '{levelname}:{name}:{message}'\n#BASIC_FORMAT = \"%(levelname)s:%(name)s:%(message)s\"\n\n_STYLES = {\n#   '%': (PercentStyle, \"%(levelname)s:%(name)s:%(message)s\"),\n    '{': (StrFormatStyle, BASIC_FORMAT),\n#   '$': (StringTemplateStyle, '${levelname}:${name}:${message}'),\n}\n\nclass Formatter(object):\n    \"\"\"\n    Formatter instances are used to convert a LogRecord to text.\n\n    Formatters need to know how a LogRecord is constructed. They are\n    responsible for converting a LogRecord to (usually) a string which can\n    be interpreted by either a human or an external system. The base Formatter\n    allows a formatting string to be specified. If none is supplied, the\n    default value of \"%s(message)\" is used.\n\n    The Formatter can be initialized with a format string which makes use of\n    knowledge of the LogRecord attributes - e.g. the default value mentioned\n    above makes use of the fact that the user's message and arguments are pre-\n    formatted into a LogRecord's message attribute. Currently, the useful\n    attributes in a LogRecord are described by:\n\n    %(name)s                        Name of the logger (logging channel)\n    %(levelno)s                 Numeric logging level for the message (DEBUG, INFO,\n                                                WARNING, ERROR, CRITICAL)\n    %(levelname)s               Text logging level for the message (\"DEBUG\", \"INFO\",\n                                                \"WARNING\", \"ERROR\", \"CRITICAL\")\n    %(pathname)s                Full pathname of the source file where the logging\n                                                call was issued (if available)\n    %(filename)s                Filename portion of pathname\n    %(module)s                  Module (name portion of filename)\n    %(lineno)d                  Source line number where the logging call was issued\n                                                (if available)\n    %(funcName)s                Function name\n    %(created)f                 Time when the LogRecord was created (time.time()\n                                                return value)\n    %(asctime)s                 Textual time when the LogRecord was created\n    %(msecs)d                       Millisecond portion of the creation time\n    %(relativeCreated)d Time in milliseconds when the LogRecord was created,\n                                                relative to the time the logging module was loaded\n                                                (typically at application startup time)\n    %(thread)d                  Thread ID (if available)\n    %(threadName)s          Thread name (if available)\n    %(process)d                 Process ID (if available)\n    %(message)s                 The result of record.getMessage(), computed just as\n                                                the record is emitted\n    \"\"\"\n\n    converter = time.localtime\n    __pragma__('kwargs')\n    def __init__(self, format=None, datefmt=None, style='{'):\n        \"\"\"\n        Initialize the formatter with specified format strings.\n\n        Initialize the formatter either with the specified format string, or a\n        default as described above. Allow for specialized date formatting with\n        the optional datefmt argument (if omitted, you get the ISO8601 format).\n\n        Use a style parameter of '%', '{' or '$' to specify that you want to\n        use one of %-formatting, :meth:`str.format` (``{}``) formatting or\n        :class:`string.Template` formatting in your format string.\n\n        .. versionchanged:: 3.2\n        Added the ``style`` parameter.\n        \"\"\"\n        # if style not in _STYLES:\n        #   raise ValueError('Style must be one of: {}'.format(','.join(_STYLES.keys())))\n        if ( style != '{' ):\n            raise NotImplementedError(\"{} format only\")\n\n        self._style = _STYLES[style][0](format)\n        self._fmt = self._style._fmt\n        self.datefmt = datefmt\n\n    __pragma__('nokwargs')\n\n    default_time_format = '%Y-%m-%d %H:%M:%S'\n    default_msec_format = '{},{:03d}'\n\n\n    def formatTime(self, record, datefmt=None):\n        \"\"\"\n        Return the creation time of the specified LogRecord as formatted text.\n\n        This method should be called from format() by a formatter which\n        wants to make use of a formatted time. This method can be overridden\n        in formatters to provide for any specific requirement, but the\n        basic behaviour is as follows: if datefmt (a string) is specified,\n        it is used with time.strftime() to format the creation time of the\n        record. Otherwise, the ISO8601 format is used. The resulting\n        string is returned. This function uses a user-configurable function\n        to convert the creation time to a tuple. By default, time.localtime()\n        is used; to change this for a particular formatter instance, set the\n        'converter' attribute to a function with the same signature as\n        time.localtime() or time.gmtime(). To change it for all formatters,\n        for example if you want all logging times to be shown in GMT,\n        set the 'converter' attribute in the Formatter class.\n        \"\"\"\n        ct = self.converter(record.created)\n        if datefmt:\n            s = time.strftime(datefmt, ct)\n        else:\n            t = time.strftime(self.default_time_format, ct)\n            s = self.default_msec_format % (t, record.msecs)\n        return s\n\n    def formatException(self, ei):\n        \"\"\"\n        Format and return the specified exception information as a string.\n\n        This default implementation just uses\n        traceback.print_exception()\n        \"\"\"\n        # @todo - we need to fix this -\n        return( str(ei) )\n        # sio = io.StringIO()\n        # tb = ei[2]\n        # # See issues #9427, #1553375. Commented out for now.\n        # #if getattr(self, 'fullstack', False):\n        # #      traceback.print_stack(tb.tb_frame.f_back, file=sio)\n        # traceback.print_exception(ei[0], ei[1], tb, None, sio)\n        # s = sio.getvalue()\n        # sio.close()\n        # if s[-1:] == \"\\n\":\n        #           s = s[:-1]\n        # return s\n\n    def usesTime(self):\n        \"\"\"\n        Check if the format uses the creation time of the record.\n        \"\"\"\n        return self._style.usesTime()\n\n    def formatMessage(self, record):\n        return self._style.format(record)\n\n    def formatStack(self, stack_info):\n        \"\"\"\n        This method is provided as an extension point for specialized\n        formatting of stack information.\n\n        The input data is a string as returned from a call to\n        :func:`traceback.print_stack`, but with the last trailing newline\n        removed.\n\n        The base implementation just returns the value passed in.\n        \"\"\"\n        return stack_info\n\n    def format(self, record):\n        \"\"\"\n        Format the specified record as text.\n\n        The record's attribute dictionary is used as the operand to a\n        string formatting operation which yields the returned string.\n        Before formatting the dictionary, a couple of preparatory steps\n        are carried out. The message attribute of the record is computed\n        using LogRecord.getMessage(). If the formatting string uses the\n        time (as determined by a call to usesTime(), formatTime() is\n        called to format the event time. If there is exception information,\n        it is formatted using formatException() and appended to the message.\n        \"\"\"\n        record.message = record.getMessage()\n        if self.usesTime():\n            record.asctime = self.formatTime(record, self.datefmt)\n        s = self.formatMessage(record)\n        if record.exc_info:\n            # Cache the traceback text to avoid converting it multiple times\n            # (it's constant anyway)\n            if not record.exc_text:\n                record.exc_text = self.formatException(record.exc_info)\n        if record.exc_text:\n            if s[len(s)-1] != \"\\n\":\n                s = s + \"\\n\"\n                s = s + record.exc_text\n        if record.stack_info:\n            if s[len(s)-1] != \"\\n\":\n                s = s + \"\\n\"\n                s = s + self.formatStack(record.stack_info)\n        return s\n\n#\n#       The default formatter to use when no other is specified\n#\n_defaultFormatter = Formatter()\n\nclass BufferingFormatter(object):\n    \"\"\"\n    A formatter suitable for formatting a number of records.\n    \"\"\"\n    def __init__(self, linefmt=None):\n        \"\"\"\n        Optionally specify a formatter which will be used to format each\n        individual record.\n        \"\"\"\n        if linefmt:\n            self.linefmt = linefmt\n        else:\n            self.linefmt = _defaultFormatter\n\n    def formatHeader(self, records):\n        \"\"\"\n        Return the header string for the specified records.\n        \"\"\"\n        return \"\"\n\n    def formatFooter(self, records):\n        \"\"\"\n        Return the footer string for the specified records.\n        \"\"\"\n        return \"\"\n\n    def format(self, records):\n        \"\"\"\n        Format the specified records and return the result as a string.\n        \"\"\"\n        rv = \"\"\n        if len(records) > 0:\n            rv = rv + self.formatHeader(records)\n            for record in records:\n                rv = rv + self.linefmt.format(record)\n                rv = rv + self.formatFooter(records)\n        return rv\n\n#---------------------------------------------------------------------------\n#       Filter classes and functions\n#---------------------------------------------------------------------------\n\nclass Filter(object):\n    \"\"\"\n    Filter instances are used to perform arbitrary filtering of LogRecords.\n\n    Loggers and Handlers can optionally use Filter instances to filter\n    records as desired. The base filter class only allows events which are\n    below a certain point in the logger hierarchy. For example, a filter\n    initialized with \"A.B\" will allow events logged by loggers \"A.B\",\n    \"A.B.C\", \"A.B.C.D\", \"A.B.D\" etc. but not \"A.BB\", \"B.A.B\" etc. If\n    initialized with the empty string, all events are passed.\n    \"\"\"\n    def __init__(self, name=''):\n        \"\"\"\n        Initialize a filter.\n\n        Initialize with the name of the logger which, together with its\n        children, will have its events allowed through the filter. If no\n        name is specified, allow every event.\n        \"\"\"\n        self.name = name\n        self.nlen = len(name)\n\n    def filter(self, record):\n        \"\"\"\n        Determine if the specified record is to be logged.\n\n        Is the specified record to be logged? Returns 0 for no, nonzero for\n        yes. If deemed appropriate, the record may be modified in-place.\n        \"\"\"\n        if self.nlen == 0:\n            return True\n        elif self.name == record.name:\n            return True\n        elif record.name.find(self.name, 0, self.nlen) != 0:\n            return False\n        return (record.name[self.nlen] == \".\")\n\nclass Filterer(object):\n    \"\"\"\n    A base class for loggers and handlers which allows them to share\n    common code.\n    \"\"\"\n    def __init__(self):\n        \"\"\"\n        Initialize the list of filters to be an empty list.\n        \"\"\"\n        self.filters = []\n\n    def addFilter(self, filt):\n        \"\"\"\n        Add the specified filter to this handler.\n        \"\"\"\n        if not (filt in self.filters):\n            self.filters.append(filt)\n\n    def removeFilter(self, filt):\n        \"\"\"\n        Remove the specified filter from this handler.\n        \"\"\"\n        if filt in self.filters:\n            self.filters.remove(filt)\n\n    def filter(self, record):\n        \"\"\"\n        Determine if a record is loggable by consulting all the filters.\n\n        The default is to allow the record to be logged; any filter can veto\n        this and the record is then dropped. Returns a zero value if a record\n        is to be dropped, else non-zero.\n\n        .. versionchanged:: 3.2\n\n        Allow filters to be just callables.\n        \"\"\"\n        rv = True\n        for f in self.filters:\n            if hasattr(f, 'filter'):\n                result = f.filter(record)\n            else:\n                result = f(record) # assume callable - will raise if not\n            if not result:\n                rv = False\n                break\n        return rv\n\n########################\n# Default Logging Stream\n########################\n# This is temporary until we\n# get a \"sys.stderr\" stream object that\n# we can target.\n\nclass ConsoleLogStream(object):\n    \"\"\" This implements a quasi \"Stream\" like object for mimicing\n    the sys.stderr object.\n    \"\"\"\n    def __init__(self):\n        self.name = \"console\"\n\n    def write(self, msg):\n        \"\"\"\n        \"\"\"\n        # The console puts a new line in for us so we\n        # need to strip off the newlines in order for\n        # the formatting to seem reasonable.\n        msg = msg.rstrip('\\n\\r')\n        if ( len(msg) > 0 ):\n            console.log(msg)\n\n_consoleStream = ConsoleLogStream()\n\n\n#---------------------------------------------------------------------------\n#       Handler classes and functions\n#---------------------------------------------------------------------------\n\n#map of handler names to handlers\n_handlers = {}\n# @todo - investigate if javascript has something like this and\n#    whether we care or want to use it.\n#_handlers = weakref.WeakValueDictionary()\n\n# added to allow handlers to be removed in reverse of order initialized\n_handlerList = []\n\ndef _removeHandlerRef(wr):\n    \"\"\"\n    Remove a handler reference from the internal cleanup list.\n    \"\"\"\n    # This function can be called during module teardown, when globals are\n    # set to None. It can also be called from another thread. So we need to\n    # pre-emptively grab the necessary globals and check if they're None,\n    # to prevent race conditions and failures during interpreter shutdown.\n    acquire, release, handlers = _acquireLock, _releaseLock, _handlerList\n    if acquire and release and handlers:\n        acquire()\n        try:\n            if wr in handlers:\n                handlers.remove(wr)\n        finally:\n            release()\n\ndef _addHandlerRef(handler):\n    \"\"\"\n    Add a handler to the internal cleanup list using a weak reference.\n    \"\"\"\n    _acquireLock()\n    try:\n        _handlerList.append(handler)\n#        _handlerList.append(weakref.ref(handler, _removeHandlerRef))\n    finally:\n        _releaseLock()\n\nclass Handler(Filterer):\n    \"\"\"\n    Handler instances dispatch logging events to specific destinations.\n\n    The base handler class. Acts as a placeholder which defines the Handler\n    interface. Handlers can optionally use Formatter instances to format\n    records as desired. By default, no formatter is specified; in this case,\n    the 'raw' message as determined by record.message is logged.\n    \"\"\"\n    def __init__(self, level=NOTSET):\n        \"\"\"\n        Initializes the instance - basically setting the formatter to None\n        and the filter list to empty.\n        \"\"\"\n        Filterer.__init__(self)\n        self._name = None\n        self.level = _checkLevel(level)\n        self.formatter = None\n        # Add the handler to the global _handlerList (for cleanup on shutdown)\n        _addHandlerRef(self)\n        self.createLock()\n\n    def get_name(self):\n        return self._name\n\n    def set_name(self, name):\n        _acquireLock()\n        try:\n            if self._name in _handlers:\n                del _handlers[self._name]\n            self._name = name\n            if name:\n                _handlers[name] = self\n        finally:\n            _releaseLock()\n\n    name = property(get_name, set_name)\n\n    def createLock(self):\n        \"\"\"\n        Acquire a thread lock for serializing access to the underlying I/O.\n        \"\"\"\n        # No Threading so we set a default value here\n        # if threading:\n        #           self.lock = threading.RLock()\n        # else: #pragma: no cover\n        #           self.lock = None\n        self.lock = None\n\n    def acquire(self):\n        \"\"\"\n        Acquire the I/O thread lock.\n        \"\"\"\n        if self.lock:\n            self.lock.acquire()\n\n    def release(self):\n        \"\"\"\n        Release the I/O thread lock.\n        \"\"\"\n        if self.lock:\n            self.lock.release()\n\n    def setLevel(self, level):\n        \"\"\"\n        Set the logging level of this handler.  level must be an int or a str.\n        \"\"\"\n        self.level = _checkLevel(level)\n\n    def format(self, record):\n        \"\"\"\n        Format the specified record.\n\n        If a formatter is set, use it. Otherwise, use the default formatter\n        for the module.\n        \"\"\"\n        if self.formatter:\n            fmt = self.formatter\n        else:\n            fmt = _defaultFormatter\n        return fmt.format(record)\n\n    def emit(self, record):\n        \"\"\"\n        Do whatever it takes to actually log the specified logging record.\n\n        This version is intended to be implemented by subclasses and so\n        raises a NotImplementedError.\n        \"\"\"\n        raise NotImplementedError(\"Must be implemented by handler\")\n\n    def handle(self, record):\n        \"\"\"\n        Conditionally emit the specified logging record.\n\n        Emission depends on filters which may have been added to the handler.\n        Wrap the actual emission of the record with acquisition/release of\n        the I/O thread lock. Returns whether the filter passed the record for\n        emission.\n        \"\"\"\n        rv = self.filter(record)\n        if rv:\n            self.acquire()\n            try:\n                self.emit(record)\n            finally:\n                self.release()\n        return rv\n\n    def setFormatter(self, fmt):\n        \"\"\"\n        Set the formatter for this handler.\n        \"\"\"\n        self.formatter = fmt\n\n    def flush(self):\n        \"\"\"\n        Ensure all logging output has been flushed.\n\n        This version does nothing and is intended to be implemented by\n        subclasses.\n        \"\"\"\n        pass\n\n    def close(self):\n        \"\"\"\n        Tidy up any resources used by the handler.\n\n        This version removes the handler from an internal map of handlers,\n        _handlers, which is used for handler lookup by name. Subclasses\n        should ensure that this gets called from overridden close()\n        methods.\n        \"\"\"\n        #get the module data lock, as we're updating a shared structure.\n        _acquireLock()\n        try:        #unlikely to raise an exception, but you never know...\n            if self._name and self._name in _handlers:\n                del _handlers[self._name]\n        finally:\n            _releaseLock()\n\n    def handleError(self, record):\n        \"\"\"\n        Handle errors which occur during an emit() call.\n\n        This method should be called from handlers when an exception is\n        encountered during an emit() call. If raiseExceptions is false,\n        exceptions get silently ignored. This is what is mostly wanted\n        for a logging system - most users will not care about errors in\n        the logging system, they are more interested in application errors.\n        You could, however, replace this with a custom handler if you wish.\n        The record which was being processed is passed in to this method.\n        \"\"\"\n        if ( raiseExceptions ):\n            raise Exception(\"Failed to log: {}\".format(record))\n        else:\n            _consoleStream.write(\"--- Logging Error ---\\n\")\n\n    def __repr__(self):\n        level = getLevelName(self.level)\n        return '<{} ({})>'.format(self.__class__.__name__, level)\n\nclass StreamHandler(Handler):\n    \"\"\"\n    A handler class which writes logging records, appropriately formatted,\n    to a stream. Note that this class does not close the stream, as\n    sys.stdout or sys.stderr may be used.\n    \"\"\"\n\n    terminator = '\\n'\n\n    def __init__(self, stream=None, level=NOTSET):\n        \"\"\"\n        Initialize the handler.\n\n        If stream is not specified, sys.stderr is used.\n        \"\"\"\n        Handler.__init__(self, level)\n        if stream is None:\n            stream = _consoleStream\n        self.stream = stream\n\n    def flush(self):\n        \"\"\"\n        Flushes the stream.\n        \"\"\"\n        self.acquire()\n        try:\n            if self.stream and hasattr(self.stream, \"flush\"):\n                self.stream.flush()\n        finally:\n            self.release()\n\n    def emit(self, record):\n        \"\"\"\n        Emit a record.\n\n        If a formatter is specified, it is used to format the record.\n        The record is then written to the stream with a trailing newline.    If\n        exception information is present, it is formatted using\n        traceback.print_exception and appended to the stream.    If the stream\n        has an 'encoding' attribute, it is used to determine how to do the\n        output to the stream.\n        \"\"\"\n        try:\n            msg = self.format(record)\n            stream = self.stream\n            stream.write(msg)\n            stream.write(self.terminator)\n            self.flush()\n        except Exception:\n            self.handleError(record)\n\n    def __repr__(self):\n        level = getLevelName(self.level)\n        name = getattr(self.stream, 'name', '')\n        if name:\n            name += ' '\n        return '<{} {}({})>'.format(self.__class__.__name__, name, level)\n\nclass FileHandler(StreamHandler):\n    \"\"\" Handler Class that is suppose to write to disk - we haven't\n    implemented this in transcrypt.\n    \"\"\"\n    def __init__(self, filename, mode='a', encoding=None, delay=False):\n        \"\"\"\n        \"\"\"\n        raise NotImplementedError(\"No Filesystem for FileHandler\")\n\nclass _StderrHandler(StreamHandler):\n    \"\"\"\n    This class is like a StreamHandler using sys.stderr, but always uses\n    whatever sys.stderr is currently set to rather than the value of\n    sys.stderr at handler construction time.\n    \"\"\"\n    def __init__(self, level=NOTSET):\n        \"\"\"\n        Initialize the handler.\n        \"\"\"\n        StreamHandler.__init__(self, None, level)\n\n    def _getStream(self):\n        return _consoleStream\n\n    stream = property(_getStream)\n\n\n_defaultLastResort = _StderrHandler(WARNING)\nlastResort = _defaultLastResort\n\n#---------------------------------------------------------------------------\n#       Manager classes and functions\n#---------------------------------------------------------------------------\n\nclass PlaceHolder(object):\n    \"\"\"\n    PlaceHolder instances are used in the Manager logger hierarchy to take\n    the place of nodes for which no loggers have been defined. This class is\n    intended for internal use only and not as part of the public API.\n    \"\"\"\n    def __init__(self, alogger):\n        \"\"\"\n        Initialize with the specified logger being a child of this placeholder.\n        \"\"\"\n        n = alogger.name\n        self.loggerMap = { n : alogger }\n\n    def append(self, alogger):\n        \"\"\"\n        Add the specified logger as a child of this placeholder.\n        \"\"\"\n        n = alogger.name\n        if n not in self.loggerMap.keys():\n            self.loggerMap[n] = alogger\n\n#\n#       Determine which class to use when instantiating loggers.\n#\n\ndef setLoggerClass(klass):\n    \"\"\"\n    Set the class to be used when instantiating a logger. The class should\n    define __init__() such that only a name argument is required, and the\n    __init__() should call Logger.__init__()\n    \"\"\"\n    if klass != Logger:\n        if not issubclass(klass, Logger):\n            raise TypeError(\"logger not derived from logging.Logger: \"\n                                            + klass.__name__)\n    global _loggerClass\n    _loggerClass = klass\n\ndef getLoggerClass():\n    \"\"\"\n    Return the class to be used when instantiating a logger.\n    \"\"\"\n    return _loggerClass\n\nclass Manager(object):\n    \"\"\"\n    There is [under normal circumstances] just one Manager instance, which\n    holds the hierarchy of loggers.\n    \"\"\"\n    def __init__(self, rootnode):\n        \"\"\"\n        Initialize the manager with the root node of the logger hierarchy.\n        \"\"\"\n        self.root = rootnode\n        self.disable = 0\n        self.emittedNoHandlerWarning = False\n        self.loggerDict = {}\n        self.loggerClass = None\n        self.logRecordFactory = None\n\n    def getLogger(self, name):\n        \"\"\"\n        Get a logger with the specified name (channel name), creating it\n        if it doesn't yet exist. This name is a dot-separated hierarchical\n        name, such as \"a\", \"a.b\", \"a.b.c\" or similar.\n\n        If a PlaceHolder existed for the specified name [i.e. the logger\n        didn't exist but a child of it did], replace it with the created\n        logger and fix up the parent/child references which pointed to the\n        placeholder to now point to the logger.\n        \"\"\"\n        rv = None\n        if not isinstance(name, str):\n            raise TypeError('A logger name must be a string')\n        _acquireLock()\n        try:\n            if name in self.loggerDict:\n                rv = self.loggerDict[name]\n                if isinstance(rv, PlaceHolder):\n                    ph = rv\n                    rv = (self.loggerClass or _loggerClass)(name)\n                    rv.manager = self\n                    self.loggerDict[name] = rv\n                    self._fixupChildren(ph, rv)\n                    self._fixupParents(rv)\n            else:\n                rv = (self.loggerClass or _loggerClass)(name)\n                rv.manager = self\n                self.loggerDict[name] = rv\n                self._fixupParents(rv)\n        finally:\n            _releaseLock()\n        return rv\n\n    def setLoggerClass(self, klass):\n        \"\"\"\n        Set the class to be used when instantiating a logger with this Manager.\n        \"\"\"\n        if klass != Logger:\n            if not issubclass(klass, Logger):\n                raise TypeError(\"logger not derived from logging.Logger: \"\n                                                + klass.__name__)\n        self.loggerClass = klass\n\n    def setLogRecordFactory(self, factory):\n        \"\"\"\n        Set the factory to be used when instantiating a log record with this\n        Manager.\n        \"\"\"\n        self.logRecordFactory = factory\n\n    def _fixupParents(self, alogger):\n        \"\"\"\n        Ensure that there are either loggers or placeholders all the way\n        from the specified logger to the root of the logger hierarchy.\n        \"\"\"\n        name = alogger.name\n        i = name.rfind(\".\")\n        rv = None\n        while (i > 0) and not rv:\n            substr = name[:i]\n            if substr not in self.loggerDict:\n                self.loggerDict[substr] = PlaceHolder(alogger)\n            else:\n                obj = self.loggerDict[substr]\n                if isinstance(obj, Logger):\n                    rv = obj\n                else:\n                    assert isinstance(obj, PlaceHolder)\n                    obj.append(alogger)\n            i = name.rfind(\".\", 0, i - 1)\n        if not rv:\n            rv = self.root\n        alogger.parent = rv\n\n    def _fixupChildren(self, ph, alogger):\n        \"\"\"\n        Ensure that children of the placeholder ph are connected to the\n        specified logger.\n        \"\"\"\n        name = alogger.name\n        namelen = len(name)\n        for c in ph.loggerMap.keys():\n            log = ph.loggerMap[c]\n            if not log.parent.name.startswith(name):\n            #The if means ... if not c.parent.name.startswith(nm)\n            #if c.parent.name[:namelen] != name:\n                alogger.parent = log.parent\n                log.parent = alogger\n\n#---------------------------------------------------------------------------\n#       Logger classes and functions\n#---------------------------------------------------------------------------\n\n\nclass Logger(Filterer):\n    \"\"\"\n    Instances of the Logger class represent a single logging channel. A\n    \"logging channel\" indicates an area of an application. Exactly how an\n    \"area\" is defined is up to the application developer. Since an\n    application can have any number of areas, logging channels are identified\n    by a unique string. Application areas can be nested (e.g. an area\n    of \"input processing\" might include sub-areas \"read CSV files\", \"read\n    XLS files\" and \"read Gnumeric files\"). To cater for this natural nesting,\n    channel names are organized into a namespace hierarchy where levels are\n    separated by periods, much like the Java or Python package namespace. So\n    in the instance given above, channel names might be \"input\" for the upper\n    level, and \"input.csv\", \"input.xls\" and \"input.gnu\" for the sub-levels.\n    There is no arbitrary limit to the depth of nesting.\n    \"\"\"\n    def __init__(self, name, level=NOTSET):\n        \"\"\"\n        Initialize the logger with a name and an optional level.\n        \"\"\"\n        Filterer.__init__(self)\n        self.name = name\n        self.level = _checkLevel(level)\n        self.parent = None\n        self.propagate = True\n        self.handlers = []\n        self.disabled = False\n\n    def setLevel(self, level):\n        \"\"\"\n        Set the logging level of this logger.    level must be an int or a str.\n        \"\"\"\n        self.level = _checkLevel(level)\n\n    __pragma__('kwargs')\n    def debug(self, msg, *args, **kwargs):\n        \"\"\"\n        Log 'msg.format(args)' with severity 'DEBUG'.\n\n        To pass exception information, use the keyword argument exc_info with\n        a true value, e.g.\n\n        logger.debug(\"Houston, we have a {}\", \"thorny problem\", exc_info=1)\n        \"\"\"\n        if self.isEnabledFor(DEBUG):\n            self._log(DEBUG, msg, args, **kwargs)\n\n    def info(self, msg, *args, **kwargs):\n        \"\"\"\n        Log 'msg.format(args)' with severity 'INFO'.\n\n        To pass exception information, use the keyword argument exc_info with\n        a true value, e.g.\n\n        logger.info(\"Houston, we have a {}\", \"interesting problem\", exc_info=1)\n        \"\"\"\n        if self.isEnabledFor(INFO):\n            self._log(INFO, msg, args, **kwargs)\n\n    def warning(self, msg, *args, **kwargs):\n        \"\"\"\n        Log 'msg.format(args)' with severity 'WARNING'.\n\n        To pass exception information, use the keyword argument exc_info with\n        a true value, e.g.\n\n        logger.warning(\"Houston, we have a {}\", \"bit of a problem\", exc_info=1)\n        \"\"\"\n        if self.isEnabledFor(WARNING):\n            self._log(WARNING, msg, args, **kwargs)\n\n    def warn(self, msg, *args, **kwargs):\n        warnings.warn_explicit(\"The `warn` method is deprecated - use `warning`\", DeprecationWarning, 'logging/__init__.py', 1388, \"logging\")\n        self.warning(msg, *args, **kwargs)\n\n    def error(self, msg, *args, **kwargs):\n        \"\"\"\n        Log 'msg.format(args)' with severity 'ERROR'.\n\n        To pass exception information, use the keyword argument exc_info with\n        a true value, e.g.\n\n        logger.error(\"Houston, we have a {}\", \"major problem\", exc_info=1)\n        \"\"\"\n        if self.isEnabledFor(ERROR):\n            self._log(ERROR, msg, args, **kwargs)\n\n    def exception(self, msg, *args, exc_info=True, **kwargs):\n        \"\"\"\n        Convenience method for logging an ERROR with exception information.\n        \"\"\"\n        self.error(msg, *args, exc_info=exc_info, **kwargs)\n\n    def critical(self, msg, *args, **kwargs):\n        \"\"\"\n        Log 'msg.format(args)' with severity 'CRITICAL'.\n\n        To pass exception information, use the keyword argument exc_info with\n        a true value, e.g.\n\n        logger.critical(\"Houston, we have a {}\", \"major disaster\", exc_info=1)\n        \"\"\"\n        if self.isEnabledFor(CRITICAL):\n            self._log(CRITICAL, msg, args, **kwargs)\n\n        fatal = critical\n\n    def log(self, level, msg, *args, **kwargs):\n        \"\"\"\n        Log 'msg.format(args)' with the integer severity 'level'.\n\n        To pass exception information, use the keyword argument exc_info with\n        a true value, e.g.\n\n        logger.log(level, \"We have a {}\", \"mysterious problem\", exc_info=1)\n        \"\"\"\n        if not isinstance(level, int):\n            if raiseExceptions:\n                raise TypeError(\"level must be an integer\")\n            else:\n                return\n        if self.isEnabledFor(level):\n            self._log(level, msg, args, **kwargs)\n\n    __pragma__ ('nokwargs')\n\n    def findCaller(self, stack_info=False):\n        \"\"\"\n        Find the stack frame of the caller so that we can note the source\n        file name, line number and function name.\n        \"\"\"\n        f = currentframe()\n        #On some versions of IronPython, currentframe() returns None if\n        #IronPython isn't run with -X:Frames.\n        # if f is not None:\n        #           f = f.f_back\n\n        rv = \"(unknown file)\", 0, \"(unknown function)\", None\n\n        # while hasattr(f, \"f_code\"):\n        #           co = f.f_code\n        #           filename = os.path.normcase(co.co_filename)\n        #           if filename == _srcfile:\n        #                   f = f.f_back\n        #                   continue\n        #           sinfo = None\n        #           if stack_info:\n        #                   sio = io.StringIO()\n        #                   sio.write('Stack (most recent call last):\\n')\n        #                   traceback.print_stack(f, file=sio)\n        #                   sinfo = sio.getvalue()\n        #                   if sinfo[-1] == '\\n':\n        #                           sinfo = sinfo[:-1]\n        #                   sio.close()\n        #           rv = (co.co_filename, f.f_lineno, co.co_name, sinfo)\n        #           break\n        return rv\n\n    def makeRecord(self, name, level, fn, lno, msg, args, exc_info,\n                                 func=None, extra=None, sinfo=None):\n        \"\"\"\n        A factory method which can be overridden in subclasses to create\n        specialized LogRecords.\n        \"\"\"\n        rv = _logRecordFactory(name, level, fn, lno, msg, args, exc_info, func,\n                                                     sinfo)\n        if extra is not None:\n            for key in extra:\n                if (key in [\"message\", \"asctime\"]) or (key in rv.__dict__):\n                    raise KeyError(\"Attempt to overwrite %r in LogRecord\" % key)\n                rv.__dict__[key] = extra[key]\n        return rv\n\n    def _log(self, level, msg, args, exc_info=None, extra=None, stack_info=False):\n        \"\"\"\n        Low-level logging routine which creates a LogRecord and then calls\n        all the handlers of this logger to handle the record.\n        \"\"\"\n        sinfo = None\n        if _srcfile:\n            #IronPython doesn't track Python frames, so findCaller raises an\n            #exception on some versions of IronPython. We trap it here so that\n            #IronPython can use logging.\n            try:\n                fn, lno, func, sinfo = self.findCaller(stack_info)\n            except ValueError: # pragma: no cover\n                fn, lno, func = \"(unknown file)\", 0, \"(unknown function)\"\n        else: # pragma: no cover\n            fn, lno, func = \"(unknown file)\", 0, \"(unknown function)\"\n        # @note - Not sure how we are going to handle this yet\n        #        Need to consider possibly implementing parts of sys\n        # if exc_info:\n        #           if isinstance(exc_info, BaseException):\n        #                   exc_info = (type(exc_info), exc_info, exc_info.__traceback__)\n        #           elif not isinstance(exc_info, tuple):\n        #                   exc_info = sys.exc_info()\n        record = self.makeRecord(self.name, level, fn, lno, msg, args,\n                                                         exc_info, func, extra, sinfo)\n        self.handle(record)\n\n    def handle(self, record):\n        \"\"\"\n        Call the handlers for the specified record.\n\n        This method is used for unpickled records received from a socket, as\n        well as those created locally. Logger-level filtering is applied.\n        \"\"\"\n        if (not self.disabled) and self.filter(record):\n            self.callHandlers(record)\n\n    def addHandler(self, hdlr):\n        \"\"\"\n        Add the specified handler to this logger.\n        \"\"\"\n        _acquireLock()\n        try:\n            if not (hdlr in self.handlers):\n                self.handlers.append(hdlr)\n        finally:\n            _releaseLock()\n\n    def removeHandler(self, hdlr):\n        \"\"\"\n        Remove the specified handler from this logger.\n        \"\"\"\n        _acquireLock()\n        try:\n            if hdlr in self.handlers:\n                self.handlers.remove(hdlr)\n        finally:\n            _releaseLock()\n\n    def hasHandlers(self):\n        \"\"\"\n        See if this logger has any handlers configured.\n\n        Loop through all handlers for this logger and its parents in the\n        logger hierarchy. Return True if a handler was found, else False.\n        Stop searching up the hierarchy whenever a logger with the \"propagate\"\n        attribute set to zero is found - that will be the last logger which\n        is checked for the existence of handlers.\n        \"\"\"\n        c = self\n        rv = False\n        while c:\n            if len(c.handlers) > 0:\n                rv = True\n                break\n            if not c.propagate:\n                break\n            else:\n                c = c.parent\n        return rv\n\n    def callHandlers(self, record):\n        \"\"\"\n        Pass a record to all relevant handlers.\n\n        Loop through all handlers for this logger and its parents in the\n        logger hierarchy. If no handler was found, output a one-off error\n        message to sys.stderr. Stop searching up the hierarchy whenever a\n        logger with the \"propagate\" attribute set to zero is found - that\n        will be the last logger whose handlers are called.\n        \"\"\"\n        c = self\n        found = 0\n        while c:\n            for hdlr in c.handlers:\n                found = found + 1\n                if record.levelno >= hdlr.level:\n                    hdlr.handle(record)\n            if not c.propagate:\n                c = None        #break out\n            else:\n                c = c.parent\n        if (found == 0):\n            if lastResort:\n                if record.levelno >= lastResort.level:\n                    lastResort.handle(record)\n            elif raiseExceptions and not self.manager.emittedNoHandlerWarning:\n                _consoleStream.write(\"No handlers could be found for logger \\\"{}\\\"\".format(self.name))\n                self.manager.emittedNoHandlerWarning = True\n\n    def getEffectiveLevel(self):\n        \"\"\"\n        Get the effective level for this logger.\n\n        Loop through this logger and its parents in the logger hierarchy,\n        looking for a non-zero logging level. Return the first one found.\n        \"\"\"\n        logger = self\n        while logger:\n            if logger.level:\n                return logger.level\n            logger = logger.parent\n        return NOTSET\n\n    def isEnabledFor(self, level):\n        \"\"\"\n        Is this logger enabled for level 'level'?\n        \"\"\"\n        if self.manager.disable >= level:\n            return False\n        return level >= self.getEffectiveLevel()\n\n    def getChild(self, suffix):\n        \"\"\"\n        Get a logger which is a descendant to this one.\n\n        This is a convenience method, such that\n\n        logging.getLogger('abc').getChild('def.ghi')\n\n        is the same as\n\n        logging.getLogger('abc.def.ghi')\n\n        It's useful, for example, when the parent logger is named using\n        __name__ rather than a literal string.\n        \"\"\"\n        if self.root is not self:\n            suffix = '.'.join((self.name, suffix))\n        return self.manager.getLogger(suffix)\n\n    def __repr__(self):\n        level = getLevelName(self.getEffectiveLevel())\n        return '<{} {} ({})>'.format(self.__class__.__name__, self.name, level)\n\n\nclass RootLogger(Logger):\n    \"\"\"\n    A root logger is not that different to any other logger, except that\n    it must have a logging level and there is only one instance of it in\n    the hierarchy.\n    \"\"\"\n    def __init__(self, level):\n        \"\"\"\n        Initialize the logger with the name \"root\".\n        \"\"\"\n        Logger.__init__(self, \"root\", level)\n\n_loggerClass = Logger\n\nclass LoggerAdapter(object):\n    \"\"\"\n    An adapter for loggers which makes it easier to specify contextual\n    information in logging output.\n    \"\"\"\n\n    def __init__(self, logger, extra):\n        \"\"\"\n        Initialize the adapter with a logger and a dict-like object which\n        provides contextual information. This constructor signature allows\n        easy stacking of LoggerAdapters, if so desired.\n\n        You can effectively pass keyword arguments as shown in the\n        following example:\n\n        adapter = LoggerAdapter(someLogger, dict(p1=v1, p2=\"v2\"))\n        \"\"\"\n        self.logger = logger\n        self.extra = extra\n\n    def process(self, msg, kwargs):\n        \"\"\"\n        Process the logging message and keyword arguments passed in to\n        a logging call to insert contextual information. You can either\n        manipulate the message itself, the keyword args or both. Return\n        the message and kwargs modified (or not) to suit your needs.\n\n        Normally, you'll only need to override this one method in a\n        LoggerAdapter subclass for your specific needs.\n        \"\"\"\n        kwargs[\"extra\"] = self.extra\n        return msg, kwargs\n\n    __pragma__('kwargs')\n    #\n    # Boilerplate convenience methods\n    #\n    def debug(self, msg, *args, **kwargs):\n        \"\"\"\n        Delegate a debug call to the underlying logger.\n        \"\"\"\n        self.log(DEBUG, msg, *args, **kwargs)\n\n    def info(self, msg, *args, **kwargs):\n        \"\"\"\n        Delegate an info call to the underlying logger.\n        \"\"\"\n        self.log(INFO, msg, *args, **kwargs)\n\n    def warning(self, msg, *args, **kwargs):\n        \"\"\"\n        Delegate a warning call to the underlying logger.\n        \"\"\"\n        self.log(WARNING, msg, *args, **kwargs)\n\n    def warn(self, msg, *args, **kwargs):\n        warnings.warn_explicit(\"The `warn` method is deprecated - use `warning`\", DeprecationWarning, 'logging/__init__.py', 1719, \"logging\")\n\n        self.warning(msg, *args, **kwargs)\n\n    def error(self, msg, *args, **kwargs):\n        \"\"\"\n        Delegate an error call to the underlying logger.\n        \"\"\"\n        self.log(ERROR, msg, *args, **kwargs)\n\n    def exception(self, msg, *args, exc_info=True, **kwargs):\n        \"\"\"\n        Delegate an exception call to the underlying logger.\n        \"\"\"\n        self.log(ERROR, msg, *args, exc_info=exc_info, **kwargs)\n\n    def critical(self, msg, *args, **kwargs):\n        \"\"\"\n        Delegate a critical call to the underlying logger.\n        \"\"\"\n        self.log(CRITICAL, msg, *args, **kwargs)\n\n    def log(self, level, msg, *args, **kwargs):\n        \"\"\"\n        Delegate a log call to the underlying logger, after adding\n        contextual information from this adapter instance.\n        \"\"\"\n        if self.isEnabledFor(level):\n            msg, kwargs = self.process(msg, kwargs)\n            self.logger._log(level, msg, args, **kwargs)\n    __pragma__('nokwargs')\n\n    def isEnabledFor(self, level):\n        \"\"\"\n        Is this logger enabled for level 'level'?\n        \"\"\"\n        if self.logger.manager.disable >= level:\n            return False\n        return level >= self.getEffectiveLevel()\n\n    def setLevel(self, level):\n        \"\"\"\n        Set the specified level on the underlying logger.\n        \"\"\"\n        self.logger.setLevel(level)\n\n    def getEffectiveLevel(self):\n        \"\"\"\n        Get the effective level for the underlying logger.\n        \"\"\"\n        return self.logger.getEffectiveLevel()\n\n    def hasHandlers(self):\n        \"\"\"\n        See if the underlying logger has any handlers.\n        \"\"\"\n        return self.logger.hasHandlers()\n\n    def __repr__(self):\n        logger = self.logger\n        level = getLevelName(logger.getEffectiveLevel())\n        return '<{} {} ({})>'.format(self.__class__.__name__, logger.name, level)\n\nroot = RootLogger(WARNING)\nLogger.root = root\nLogger.manager = Manager(Logger.root)\n# @note - this is necessary because I think there may be a bug\n# in the way that class level attributes are distributed to\n# instances of a class\nroot.manager = Logger.manager\n\ndef _resetLogging():\n    \"\"\" This is a utility method to help with testing so that\n    we can start from a clean slate.\n    \"\"\"\n    _handlerList = []\n    _handlers = {}\n    global root\n    root = RootLogger(WARNING)\n    Logger.root = root\n    Logger.manager = Manager(Logger.root)\n    # @note - this is necessary because I think there may be a bug\n    # in the way that class level attributes are distributed to\n    # instances of a class\n    root.manager = Logger.manager\n\n#---------------------------------------------------------------------------\n# Configuration classes and functions\n#---------------------------------------------------------------------------\n__pragma__('kwargs')\ndef basicConfig(**kwargs):\n    \"\"\"\n    Do basic configuration for the logging system.\n\n    This function does nothing if the root logger already has handlers\n    configured. It is a convenience method intended for use by simple scripts\n    to do one-shot configuration of the logging package.\n\n    The default behaviour is to create a StreamHandler which writes to\n    console.log, set a formatter using the BASIC_FORMAT format string, and\n    add the handler to the root logger.\n\n    A number of optional keyword arguments may be specified, which can alter\n    the default behaviour.\n\n    format      Use the specified format string for the handler.\n    datefmt     Use the specified date/time format.\n    style           If a format string is specified, use this to specify the\n                            type of format string (possible values '%', '{', '$', for\n                            %-formatting, :meth:`str.format` and :class:`string.Template`\n                            - defaults to '%').\n    level           Set the root logger level to the specified level.\n    stream      Use the specified stream to initialize the StreamHandler. Note\n                            that this argument is incompatible with 'filename' - if both\n                            are present, 'stream' is ignored.\n    handlers    If specified, this should be an iterable of already created\n                            handlers, which will be added to the root handler. Any handler\n                            in the list which does not have a formatter assigned will be\n                            assigned the formatter created in this function.\n\n    .. versionchanged:: 3.2\n    Added the ``style`` parameter.\n\n    .. versionchanged:: 3.3\n    Added the ``handlers`` parameter. A ``ValueError`` is now thrown for\n    incompatible arguments (e.g. ``handlers`` specified together with\n    ``filename``/``filemode``, or ``filename``/``filemode`` specified\n    together with ``stream``, or ``handlers`` specified together with\n    ``stream``.\n    \"\"\"\n    # Add thread safety in case someone mistakenly calls\n    # basicConfig() from multiple threads\n    _acquireLock()\n    try:\n        if len(root.handlers) == 0:\n            handlers = kwargs.pop(\"handlers\", None)\n            if handlers is not None:\n                if \"stream\" in kwargs:\n                    raise ValueError(\"'stream' should not be \"\n                                     \"specified together with 'handlers'\")\n            if handlers is None:\n                stream = kwargs.pop(\"stream\", None)\n                h = StreamHandler(stream)\n                handlers = [h]\n            dfs = kwargs.pop(\"datefmt\", None)\n            style = kwargs.pop(\"style\", '{')\n            if style not in _STYLES:\n                raise ValueError('Style must be one of: {}'.format(','.join(_STYLES.keys())))\n            fs = kwargs.pop(\"format\", _STYLES[style][1])\n            fmt = Formatter(fs, dfs, style)\n            for h in handlers:\n                if h.formatter is None:\n                    h.setFormatter(fmt)\n                root.addHandler(h)\n            level = kwargs.pop(\"level\", None)\n            if level is not None:\n                root.setLevel(level)\n            if len(kwargs) > 0:\n                keys = ', '.join(kwargs.keys())\n                raise ValueError('Unrecognised argument(s): {}'.format(keys))\n    finally:\n        _releaseLock()\n\n__pragma__('nokwargs')\n\n#---------------------------------------------------------------------------\n# Utility functions at module level.\n# Basically delegate everything to the root logger.\n#---------------------------------------------------------------------------\n\ndef getLogger(name=None):\n    \"\"\"\n    Return a logger with the specified name, creating it if necessary.\n\n    If no name is specified, return the root logger.\n    \"\"\"\n    if name:\n        return Logger.manager.getLogger(name)\n    else:\n        return root\n\n__pragma__('kwargs')\ndef critical(msg, *args, **kwargs):\n    \"\"\"\n    Log a message with severity 'CRITICAL' on the root logger. If the logger\n    has no handlers, call basicConfig() to add a console handler with a\n    pre-defined format.\n    \"\"\"\n    if len(root.handlers) == 0:\n        basicConfig()\n    root.critical(msg, *args, **kwargs)\n\nfatal = critical\n\ndef error(msg, *args, **kwargs):\n    \"\"\"\n    Log a message with severity 'ERROR' on the root logger. If the logger has\n    no handlers, call basicConfig() to add a console handler with a pre-defined\n    format.\n    \"\"\"\n    if len(root.handlers) == 0:\n        basicConfig()\n    root.error(msg, *args, **kwargs)\n\ndef exception(msg, *args, exc_info=True, **kwargs):\n    \"\"\"\n    Log a message with severity 'ERROR' on the root logger, with exception\n    information. If the logger has no handlers, basicConfig() is called to add\n    a console handler with a pre-defined format.\n    \"\"\"\n    error(msg, *args, exc_info=exc_info, **kwargs)\n\ndef warning(msg, *args, **kwargs):\n    \"\"\"\n    Log a message with severity 'WARNING' on the root logger. If the logger has\n    no handlers, call basicConfig() to add a console handler with a pre-defined\n    format.\n    \"\"\"\n    if len(root.handlers) == 0:\n        basicConfig()\n    root.warning(msg, *args, **kwargs)\n\ndef warn(msg, *args, **kwargs):\n    warnings.warn_explicit(\"The `warn` method is deprecated - use `warning`\", DeprecationWarning, 'logging/__init__.py', 1944, \"logging\")\n    warning(msg, *args, **kwargs)\n\ndef info(msg, *args, **kwargs):\n    \"\"\"\n    Log a message with severity 'INFO' on the root logger. If the logger has\n    no handlers, call basicConfig() to add a console handler with a pre-defined\n    format.\n    \"\"\"\n    if len(root.handlers) == 0:\n        basicConfig()\n    root.info(msg, *args, **kwargs)\n\ndef debug(msg, *args, **kwargs):\n    \"\"\"\n    Log a message with severity 'DEBUG' on the root logger. If the logger has\n    no handlers, call basicConfig() to add a console handler with a pre-defined\n    format.\n    \"\"\"\n    if len(root.handlers) == 0:\n        basicConfig()\n    root.debug(msg, *args, **kwargs)\n\ndef log(level, msg, *args, **kwargs):\n    \"\"\"\n    Log 'msg.format(args)' with the integer severity 'level' on the root logger. If\n    the logger has no handlers, call basicConfig() to add a console handler\n    with a pre-defined format.\n    \"\"\"\n    if len(root.handlers) == 0:\n        basicConfig()\n    root.log(level, msg, *args, **kwargs)\n__pragma__('nokwargs')\n\ndef disable(level):\n    \"\"\"\n    Disable all logging calls of severity 'level' and below.\n    \"\"\"\n    root.manager.disable = level\n\ndef shutdown(handlerList=_handlerList):\n    \"\"\"\n    Perform any cleanup actions in the logging system (e.g. flushing\n    buffers).\n\n    Should be called at application exit.\n    \"\"\"\n    for wr in reversed(handlerList[:]):\n        #errors might occur, for example, if files are locked\n        #we just ignore them if raiseExceptions is not set\n        try:\n            h = wr()\n            if h:\n                try:\n                    h.acquire()\n                    h.flush()\n                    h.close()\n                except (OSError, ValueError):\n                    # Ignore errors which might be caused\n                    # because handlers have been closed but\n                    # references to them are still around at\n                    # application exit.\n                    pass\n                finally:\n                    h.release()\n        except Exception as exc: # ignore everything, as we're shutting down\n            if raiseExceptions:\n                raise exc\n            #else, swallow\n\n#Let's try and shutdown automatically on application exit...\n# @note - this is not implemented yet - not sure it\n#       event makes sense for this application\n#import atexit\n#atexit.register(shutdown)\n\n# Null handler\n\nclass NullHandler(Handler):\n    \"\"\"\n    This handler does nothing. It's intended to be used to avoid the\n    \"No handlers could be found for logger XXX\" one-off warning. This is\n    important for library code, which may contain code to log events. If a user\n    of the library does not configure logging, the one-off warning might be\n    produced; to avoid this, the library developer simply needs to instantiate\n    a NullHandler and add it to the top-level logger of the library module or\n    package.\n        \"\"\"\n    def handle(self, record):\n        \"\"\"Stub.\"\"\"\n\n    def emit(self, record):\n        \"\"\"Stub.\"\"\"\n\n    def createLock(self):\n        self.lock = None\n\n# Warnings integration\n\n_warnings_showwarning = None\n\ndef _showwarning(message, category, filename, lineno, file=None, line=None):\n    \"\"\"\n    Implementation of showwarnings which redirects to logging, which will first\n    check to see if the file parameter is None. If a file is specified, it will\n    delegate to the original warnings implementation of showwarning. Otherwise,\n    it will call warnings.formatwarning and will log the resulting string to a\n    warnings logger named \"py.warnings\" with level logging.WARNING.\n    \"\"\"\n    if file is not None:\n        if _warnings_showwarning is not None:\n            _warnings_showwarning(message, category, filename, lineno, file, line)\n    else:\n        s = warnings.formatwarning(message, category, filename, lineno, line)\n        logger = getLogger(\"py.warnings\")\n        if not logger.handlers:\n            logger.addHandler(NullHandler())\n        logger.warning(s)\n\ndef captureWarnings(capture):\n    \"\"\"\n    If capture is true, redirect all warnings to the logging package.\n    If capture is False, ensure that warnings are not redirected to logging\n    but to their original destinations.\n    \"\"\"\n    global _warnings_showwarning\n    if capture:\n        if _warnings_showwarning is None:\n            _warnings_showwarning = warnings.showwarning\n            warnings.setShowWarning(_showwarning)\n    else:\n        if _warnings_showwarning is not None:\n            warnings.setShowWarnings(_warnings_showwarning)\n            _warnings_showwarning = None\n",
		"# api wrapper for three.js\n__pragma__ ('noanno')\n\ndef _ctor(obj):\n    def _c_(*args):\n        return __new__(obj (*args))\n    return _c_\n\napi = __pragma__ ('js',\n    '{}',\n    'THREE'\n    ,\n    __include__('org/threejs/__javascript__/three.js')\n)\n\nWebGLRenderTargetCube = _ctor(api.WebGLRenderTargetCube)\nWebGLRenderTarget = _ctor(api.WebGLRenderTarget)\nWebGLRenderer = _ctor(api.WebGLRenderer)\nShaderLib = _ctor(api.ShaderLib)\nUniformsLib = _ctor(api.UniformsLib)\nUniformsUtils = _ctor(api.UniformsUtils)\nShaderChunk = _ctor(api.ShaderChunk)\nFogExp2 = _ctor(api.FogExp2)\nFog = _ctor(api.Fog)\nScene = _ctor(api.Scene)\nLensFlare = _ctor(api.LensFlare)\nSprite = _ctor(api.Sprite)\nLOD = _ctor(api.LOD)\nSkinnedMesh = _ctor(api.SkinnedMesh)\nSkeleton = _ctor(api.Skeleton)\nBone = _ctor(api.Bone)\nMesh = _ctor(api.Mesh)\nLineSegments = _ctor(api.LineSegments)\nLineLoop = _ctor(api.LineLoop)\nLine = _ctor(api.Line)\nPoints = _ctor(api.Points)\nGroup = _ctor(api.Group)\nVideoTexture = _ctor(api.VideoTexture)\nDataTexture = _ctor(api.DataTexture)\nCompressedTexture = _ctor(api.CompressedTexture)\nCubeTexture = _ctor(api.CubeTexture)\nCanvasTexture = _ctor(api.CanvasTexture)\nDepthTexture = _ctor(api.DepthTexture)\nTexture = _ctor(api.Texture)\nCompressedTextureLoader = _ctor(api.CompressedTextureLoader)\nDataTextureLoader = _ctor(api.DataTextureLoader)\nCubeTextureLoader = _ctor(api.CubeTextureLoader)\nTextureLoader = _ctor(api.TextureLoader)\nObjectLoader = _ctor(api.ObjectLoader)\nMaterialLoader = _ctor(api.MaterialLoader)\nBufferGeometryLoader = _ctor(api.BufferGeometryLoader)\nDefaultLoadingManager = _ctor(api.DefaultLoadingManager)\nLoadingManager = _ctor(api.LoadingManager)\nJSONLoader = _ctor(api.JSONLoader)\nImageLoader = _ctor(api.ImageLoader)\nFontLoader = _ctor(api.FontLoader)\nFileLoader = _ctor(api.FileLoader)\nLoader = _ctor(api.Loader)\nCache = _ctor(api.Cache)\nAudioLoader = _ctor(api.AudioLoader)\nSpotLightShadow = _ctor(api.SpotLightShadow)\nSpotLight = _ctor(api.SpotLight)\nPointLight = _ctor(api.PointLight)\nRectAreaLight = _ctor(api.RectAreaLight)\nHemisphereLight = _ctor(api.HemisphereLight)\nDirectionalLightShadow = _ctor(api.DirectionalLightShadow)\nDirectionalLight = _ctor(api.DirectionalLight)\nAmbientLight = _ctor(api.AmbientLight)\nLightShadow = _ctor(api.LightShadow)\nLight = _ctor(api.Light)\nStereoCamera = _ctor(api.StereoCamera)\nPerspectiveCamera = _ctor(api.PerspectiveCamera)\nOrthographicCamera = _ctor(api.OrthographicCamera)\nCubeCamera = _ctor(api.CubeCamera)\nArrayCamera = _ctor(api.ArrayCamera)\nCamera = _ctor(api.Camera)\nAudioListener = _ctor(api.AudioListener)\nPositionalAudio = _ctor(api.PositionalAudio)\nAudioContext = _ctor(api.AudioContext)\nAudioAnalyser = _ctor(api.AudioAnalyser)\nAudio = _ctor(api.Audio)\nVectorKeyframeTrack = _ctor(api.VectorKeyframeTrack)\nStringKeyframeTrack = _ctor(api.StringKeyframeTrack)\nQuaternionKeyframeTrack = _ctor(api.QuaternionKeyframeTrack)\nNumberKeyframeTrack = _ctor(api.NumberKeyframeTrack)\nColorKeyframeTrack = _ctor(api.ColorKeyframeTrack)\nBooleanKeyframeTrack = _ctor(api.BooleanKeyframeTrack)\nPropertyMixer = _ctor(api.PropertyMixer)\nPropertyBinding = _ctor(api.PropertyBinding)\nKeyframeTrack = _ctor(api.KeyframeTrack)\nAnimationUtils = _ctor(api.AnimationUtils)\nAnimationObjectGroup = _ctor(api.AnimationObjectGroup)\nAnimationMixer = _ctor(api.AnimationMixer)\nAnimationClip = _ctor(api.AnimationClip)\nUniform = _ctor(api.Uniform)\nInstancedBufferGeometry = _ctor(api.InstancedBufferGeometry)\nBufferGeometry = _ctor(api.BufferGeometry)\nGeometryIdCount = _ctor(api.GeometryIdCount)\nGeometry = _ctor(api.Geometry)\nInterleavedBufferAttribute = _ctor(api.InterleavedBufferAttribute)\nInstancedInterleavedBuffer = _ctor(api.InstancedInterleavedBuffer)\nInterleavedBuffer = _ctor(api.InterleavedBuffer)\nInstancedBufferAttribute = _ctor(api.InstancedBufferAttribute)\nFace3 = _ctor(api.Face3)\nObject3D = _ctor(api.Object3D)\nRaycaster = _ctor(api.Raycaster)\nLayers = _ctor(api.Layers)\nEventDispatcher = _ctor(api.EventDispatcher)\nClock = _ctor(api.Clock)\nQuaternionLinearInterpolant = _ctor(api.QuaternionLinearInterpolant)\nLinearInterpolant = _ctor(api.LinearInterpolant)\nDiscreteInterpolant = _ctor(api.DiscreteInterpolant)\nCubicInterpolant = _ctor(api.CubicInterpolant)\nInterpolant = _ctor(api.Interpolant)\nTriangle = _ctor(api.Triangle)\nMath = _ctor(api.Math)\nSpherical = _ctor(api.Spherical)\nCylindrical = _ctor(api.Cylindrical)\nPlane = _ctor(api.Plane)\nFrustum = _ctor(api.Frustum)\nSphere = _ctor(api.Sphere)\nRay = _ctor(api.Ray)\nMatrix4 = _ctor(api.Matrix4)\nMatrix3 = _ctor(api.Matrix3)\nBox3 = _ctor(api.Box3)\nBox2 = _ctor(api.Box2)\nLine3 = _ctor(api.Line3)\nEuler = _ctor(api.Euler)\nVector3 = _ctor(api.Vector3)\nQuaternion = _ctor(api.Quaternion)\nColor = _ctor(api.Color)\nMorphBlendMesh = _ctor(api.MorphBlendMesh)\nImmediateRenderObject = _ctor(api.ImmediateRenderObject)\nVertexNormalsHelper = _ctor(api.VertexNormalsHelper)\nSpotLightHelper = _ctor(api.SpotLightHelper)\nSkeletonHelper = _ctor(api.SkeletonHelper)\nPointLightHelper = _ctor(api.PointLightHelper)\nRectAreaLightHelper = _ctor(api.RectAreaLightHelper)\nHemisphereLightHelper = _ctor(api.HemisphereLightHelper)\nGridHelper = _ctor(api.GridHelper)\nPolarGridHelper = _ctor(api.PolarGridHelper)\nFaceNormalsHelper = _ctor(api.FaceNormalsHelper)\nDirectionalLightHelper = _ctor(api.DirectionalLightHelper)\nCameraHelper = _ctor(api.CameraHelper)\nBoxHelper = _ctor(api.BoxHelper)\nArrowHelper = _ctor(api.ArrowHelper)\nAxisHelper = _ctor(api.AxisHelper)\nCatmullRomCurve3 = _ctor(api.CatmullRomCurve3)\nCubicBezierCurve3 = _ctor(api.CubicBezierCurve3)\nQuadraticBezierCurve3 = _ctor(api.QuadraticBezierCurve3)\nLineCurve3 = _ctor(api.LineCurve3)\nArcCurve = _ctor(api.ArcCurve)\nEllipseCurve = _ctor(api.EllipseCurve)\nSplineCurve = _ctor(api.SplineCurve)\nCubicBezierCurve = _ctor(api.CubicBezierCurve)\nQuadraticBezierCurve = _ctor(api.QuadraticBezierCurve)\nLineCurve = _ctor(api.LineCurve)\nShape = _ctor(api.Shape)\nPath = _ctor(api.Path)\nShapePath = _ctor(api.ShapePath)\nFont = _ctor(api.Font)\nCurvePath = _ctor(api.CurvePath)\nCurve = _ctor(api.Curve)\nShapeUtils = _ctor(api.ShapeUtils)\nSceneUtils = _ctor(api.SceneUtils)\nWireframeGeometry = _ctor(api.WireframeGeometry)\nParametricGeometry = _ctor(api.ParametricGeometry)\nParametricBufferGeometry = _ctor(api.ParametricBufferGeometry)\nTetrahedronGeometry = _ctor(api.TetrahedronGeometry)\nTetrahedronBufferGeometry = _ctor(api.TetrahedronBufferGeometry)\nOctahedronGeometry = _ctor(api.OctahedronGeometry)\nOctahedronBufferGeometry = _ctor(api.OctahedronBufferGeometry)\nIcosahedronGeometry = _ctor(api.IcosahedronGeometry)\nIcosahedronBufferGeometry = _ctor(api.IcosahedronBufferGeometry)\nDodecahedronGeometry = _ctor(api.DodecahedronGeometry)\nDodecahedronBufferGeometry = _ctor(api.DodecahedronBufferGeometry)\nPolyhedronGeometry = _ctor(api.PolyhedronGeometry)\nPolyhedronBufferGeometry = _ctor(api.PolyhedronBufferGeometry)\nTubeGeometry = _ctor(api.TubeGeometry)\nTubeBufferGeometry = _ctor(api.TubeBufferGeometry)\nTorusKnotGeometry = _ctor(api.TorusKnotGeometry)\nTorusKnotBufferGeometry = _ctor(api.TorusKnotBufferGeometry)\nTorusGeometry = _ctor(api.TorusGeometry)\nTorusBufferGeometry = _ctor(api.TorusBufferGeometry)\nTextGeometry = _ctor(api.TextGeometry)\nTextBufferGeometry = _ctor(api.TextBufferGeometry)\nSphereGeometry = _ctor(api.SphereGeometry)\nSphereBufferGeometry = _ctor(api.SphereBufferGeometry)\nRingGeometry = _ctor(api.RingGeometry)\nRingBufferGeometry = _ctor(api.RingBufferGeometry)\nPlaneGeometry = _ctor(api.PlaneGeometry)\nPlaneBufferGeometry = _ctor(api.PlaneBufferGeometry)\nLatheGeometry = _ctor(api.LatheGeometry)\nLatheBufferGeometry = _ctor(api.LatheBufferGeometry)\nShapeGeometry = _ctor(api.ShapeGeometry)\nShapeBufferGeometry = _ctor(api.ShapeBufferGeometry)\nExtrudeGeometry = _ctor(api.ExtrudeGeometry)\nExtrudeBufferGeometry = _ctor(api.ExtrudeBufferGeometry)\nEdgesGeometry = _ctor(api.EdgesGeometry)\nConeGeometry = _ctor(api.ConeGeometry)\nConeBufferGeometry = _ctor(api.ConeBufferGeometry)\nCylinderGeometry = _ctor(api.CylinderGeometry)\nCylinderBufferGeometry = _ctor(api.CylinderBufferGeometry)\nCircleGeometry = _ctor(api.CircleGeometry)\nCircleBufferGeometry = _ctor(api.CircleBufferGeometry)\nBoxGeometry = _ctor(api.BoxGeometry)\nBoxBufferGeometry = _ctor(api.BoxBufferGeometry)\nShadowMaterial = _ctor(api.ShadowMaterial)\nSpriteMaterial = _ctor(api.SpriteMaterial)\nRawShaderMaterial = _ctor(api.RawShaderMaterial)\nShaderMaterial = _ctor(api.ShaderMaterial)\nPointsMaterial = _ctor(api.PointsMaterial)\nMeshPhysicalMaterial = _ctor(api.MeshPhysicalMaterial)\nMeshStandardMaterial = _ctor(api.MeshStandardMaterial)\nMeshPhongMaterial = _ctor(api.MeshPhongMaterial)\nMeshToonMaterial = _ctor(api.MeshToonMaterial)\nMeshNormalMaterial = _ctor(api.MeshNormalMaterial)\nMeshLambertMaterial = _ctor(api.MeshLambertMaterial)\nMeshDepthMaterial = _ctor(api.MeshDepthMaterial)\nMeshBasicMaterial = _ctor(api.MeshBasicMaterial)\nLineDashedMaterial = _ctor(api.LineDashedMaterial)\nLineBasicMaterial = _ctor(api.LineBasicMaterial)\nMaterial = _ctor(api.Material)\nFloat64BufferAttribute = _ctor(api.Float64BufferAttribute)\nFloat32BufferAttribute = _ctor(api.Float32BufferAttribute)\nUint32BufferAttribute = _ctor(api.Uint32BufferAttribute)\nInt32BufferAttribute = _ctor(api.Int32BufferAttribute)\nUint16BufferAttribute = _ctor(api.Uint16BufferAttribute)\nInt16BufferAttribute = _ctor(api.Int16BufferAttribute)\nUint8ClampedBufferAttribute = _ctor(api.Uint8ClampedBufferAttribute)\nUint8BufferAttribute = _ctor(api.Uint8BufferAttribute)\nInt8BufferAttribute = _ctor(api.Int8BufferAttribute)\nBufferAttribute = _ctor(api.BufferAttribute)\nREVISION = _ctor(api.REVISION)\nMOUSE = _ctor(api.MOUSE)\nCullFaceNone = _ctor(api.CullFaceNone)\nCullFaceBack = _ctor(api.CullFaceBack)\nCullFaceFront = _ctor(api.CullFaceFront)\nCullFaceFrontBack = _ctor(api.CullFaceFrontBack)\nFrontFaceDirectionCW = _ctor(api.FrontFaceDirectionCW)\nFrontFaceDirectionCCW = _ctor(api.FrontFaceDirectionCCW)\nBasicShadowMap = _ctor(api.BasicShadowMap)\nPCFShadowMap = _ctor(api.PCFShadowMap)\nPCFSoftShadowMap = _ctor(api.PCFSoftShadowMap)\nFrontSide = _ctor(api.FrontSide)\nBackSide = _ctor(api.BackSide)\nDoubleSide = _ctor(api.DoubleSide)\nFlatShading = _ctor(api.FlatShading)\nSmoothShading = _ctor(api.SmoothShading)\nNoColors = _ctor(api.NoColors)\nFaceColors = _ctor(api.FaceColors)\nVertexColors = _ctor(api.VertexColors)\nNoBlending = _ctor(api.NoBlending)\nNormalBlending = _ctor(api.NormalBlending)\nAdditiveBlending = _ctor(api.AdditiveBlending)\nSubtractiveBlending = _ctor(api.SubtractiveBlending)\nMultiplyBlending = _ctor(api.MultiplyBlending)\nCustomBlending = _ctor(api.CustomBlending)\nAddEquation = _ctor(api.AddEquation)\nSubtractEquation = _ctor(api.SubtractEquation)\nReverseSubtractEquation = _ctor(api.ReverseSubtractEquation)\nMinEquation = _ctor(api.MinEquation)\nMaxEquation = _ctor(api.MaxEquation)\nZeroFactor = _ctor(api.ZeroFactor)\nOneFactor = _ctor(api.OneFactor)\nSrcColorFactor = _ctor(api.SrcColorFactor)\nOneMinusSrcColorFactor = _ctor(api.OneMinusSrcColorFactor)\nSrcAlphaFactor = _ctor(api.SrcAlphaFactor)\nOneMinusSrcAlphaFactor = _ctor(api.OneMinusSrcAlphaFactor)\nDstAlphaFactor = _ctor(api.DstAlphaFactor)\nOneMinusDstAlphaFactor = _ctor(api.OneMinusDstAlphaFactor)\nDstColorFactor = _ctor(api.DstColorFactor)\nOneMinusDstColorFactor = _ctor(api.OneMinusDstColorFactor)\nSrcAlphaSaturateFactor = _ctor(api.SrcAlphaSaturateFactor)\nNeverDepth = _ctor(api.NeverDepth)\nAlwaysDepth = _ctor(api.AlwaysDepth)\nLessDepth = _ctor(api.LessDepth)\nLessEqualDepth = _ctor(api.LessEqualDepth)\nEqualDepth = _ctor(api.EqualDepth)\nGreaterEqualDepth = _ctor(api.GreaterEqualDepth)\nGreaterDepth = _ctor(api.GreaterDepth)\nNotEqualDepth = _ctor(api.NotEqualDepth)\nMultiplyOperation = _ctor(api.MultiplyOperation)\nMixOperation = _ctor(api.MixOperation)\nAddOperation = _ctor(api.AddOperation)\nNoToneMapping = _ctor(api.NoToneMapping)\nLinearToneMapping = _ctor(api.LinearToneMapping)\nReinhardToneMapping = _ctor(api.ReinhardToneMapping)\nUncharted2ToneMapping = _ctor(api.Uncharted2ToneMapping)\nCineonToneMapping = _ctor(api.CineonToneMapping)\nUVMapping = _ctor(api.UVMapping)\nCubeReflectionMapping = _ctor(api.CubeReflectionMapping)\nCubeRefractionMapping = _ctor(api.CubeRefractionMapping)\nEquirectangularReflectionMapping = _ctor(api.EquirectangularReflectionMapping)\nEquirectangularRefractionMapping = _ctor(api.EquirectangularRefractionMapping)\nSphericalReflectionMapping = _ctor(api.SphericalReflectionMapping)\nCubeUVReflectionMapping = _ctor(api.CubeUVReflectionMapping)\nCubeUVRefractionMapping = _ctor(api.CubeUVRefractionMapping)\nRepeatWrapping = _ctor(api.RepeatWrapping)\nClampToEdgeWrapping = _ctor(api.ClampToEdgeWrapping)\nMirroredRepeatWrapping = _ctor(api.MirroredRepeatWrapping)\nNearestFilter = _ctor(api.NearestFilter)\nNearestMipMapNearestFilter = _ctor(api.NearestMipMapNearestFilter)\nNearestMipMapLinearFilter = _ctor(api.NearestMipMapLinearFilter)\nLinearFilter = _ctor(api.LinearFilter)\nLinearMipMapNearestFilter = _ctor(api.LinearMipMapNearestFilter)\nLinearMipMapLinearFilter = _ctor(api.LinearMipMapLinearFilter)\nUnsignedByteType = _ctor(api.UnsignedByteType)\nByteType = _ctor(api.ByteType)\nShortType = _ctor(api.ShortType)\nUnsignedShortType = _ctor(api.UnsignedShortType)\nIntType = _ctor(api.IntType)\nUnsignedIntType = _ctor(api.UnsignedIntType)\nFloatType = _ctor(api.FloatType)\nHalfFloatType = _ctor(api.HalfFloatType)\nUnsignedShort4444Type = _ctor(api.UnsignedShort4444Type)\nUnsignedShort5551Type = _ctor(api.UnsignedShort5551Type)\nUnsignedShort565Type = _ctor(api.UnsignedShort565Type)\nUnsignedInt248Type = _ctor(api.UnsignedInt248Type)\nAlphaFormat = _ctor(api.AlphaFormat)\nRGBFormat = _ctor(api.RGBFormat)\nRGBAFormat = _ctor(api.RGBAFormat)\nLuminanceFormat = _ctor(api.LuminanceFormat)\nLuminanceAlphaFormat = _ctor(api.LuminanceAlphaFormat)\nRGBEFormat = _ctor(api.RGBEFormat)\nDepthFormat = _ctor(api.DepthFormat)\nDepthStencilFormat = _ctor(api.DepthStencilFormat)\nRGB_S3TC_DXT1_Format = _ctor(api.RGB_S3TC_DXT1_Format)\nRGBA_S3TC_DXT1_Format = _ctor(api.RGBA_S3TC_DXT1_Format)\nRGBA_S3TC_DXT3_Format = _ctor(api.RGBA_S3TC_DXT3_Format)\nRGBA_S3TC_DXT5_Format = _ctor(api.RGBA_S3TC_DXT5_Format)\nRGB_PVRTC_4BPPV1_Format = _ctor(api.RGB_PVRTC_4BPPV1_Format)\nRGB_PVRTC_2BPPV1_Format = _ctor(api.RGB_PVRTC_2BPPV1_Format)\nRGBA_PVRTC_4BPPV1_Format = _ctor(api.RGBA_PVRTC_4BPPV1_Format)\nRGBA_PVRTC_2BPPV1_Format = _ctor(api.RGBA_PVRTC_2BPPV1_Format)\nRGB_ETC1_Format = _ctor(api.RGB_ETC1_Format)\nLoopOnce = _ctor(api.LoopOnce)\nLoopRepeat = _ctor(api.LoopRepeat)\nLoopPingPong = _ctor(api.LoopPingPong)\nInterpolateDiscrete = _ctor(api.InterpolateDiscrete)\nInterpolateLinear = _ctor(api.InterpolateLinear)\nInterpolateSmooth = _ctor(api.InterpolateSmooth)\nZeroCurvatureEnding = _ctor(api.ZeroCurvatureEnding)\nZeroSlopeEnding = _ctor(api.ZeroSlopeEnding)\nWrapAroundEnding = _ctor(api.WrapAroundEnding)\nTrianglesDrawMode = _ctor(api.TrianglesDrawMode)\nTriangleStripDrawMode = _ctor(api.TriangleStripDrawMode)\nTriangleFanDrawMode = _ctor(api.TriangleFanDrawMode)\nLinearEncoding = _ctor(api.LinearEncoding)\nsRGBEncoding = _ctor(api.sRGBEncoding)\nGammaEncoding = _ctor(api.GammaEncoding)\nRGBEEncoding = _ctor(api.RGBEEncoding)\nLogLuvEncoding = _ctor(api.LogLuvEncoding)\nRGBM7Encoding = _ctor(api.RGBM7Encoding)\nRGBM16Encoding = _ctor(api.RGBM16Encoding)\nRGBDEncoding = _ctor(api.RGBDEncoding)\nBasicDepthPacking = _ctor(api.BasicDepthPacking)\nRGBADepthPacking = _ctor(api.RGBADepthPacking)\nCubeGeometry = _ctor(api.CubeGeometry)\nFace4 = _ctor(api.Face4)\nLineStrip = _ctor(api.LineStrip)\nLinePieces = _ctor(api.LinePieces)\nMeshFaceMaterial = _ctor(api.MeshFaceMaterial)\nMultiMaterial = _ctor(api.MultiMaterial)\nPointCloud = _ctor(api.PointCloud)\nParticle = _ctor(api.Particle)\nParticleSystem = _ctor(api.ParticleSystem)\nPointCloudMaterial = _ctor(api.PointCloudMaterial)\nParticleBasicMaterial = _ctor(api.ParticleBasicMaterial)\nParticleSystemMaterial = _ctor(api.ParticleSystemMaterial)\nVertex = _ctor(api.Vertex)\nDynamicBufferAttribute = _ctor(api.DynamicBufferAttribute)\nInt8Attribute = _ctor(api.Int8Attribute)\nUint8Attribute = _ctor(api.Uint8Attribute)\nUint8ClampedAttribute = _ctor(api.Uint8ClampedAttribute)\nInt16Attribute = _ctor(api.Int16Attribute)\nUint16Attribute = _ctor(api.Uint16Attribute)\nInt32Attribute = _ctor(api.Int32Attribute)\nUint32Attribute = _ctor(api.Uint32Attribute)\nFloat32Attribute = _ctor(api.Float32Attribute)\nFloat64Attribute = _ctor(api.Float64Attribute)\nClosedSplineCurve3 = _ctor(api.ClosedSplineCurve3)\nSplineCurve3 = _ctor(api.SplineCurve3)\nSpline = _ctor(api.Spline)\nBoundingBoxHelper = _ctor(api.BoundingBoxHelper)\nEdgesHelper = _ctor(api.EdgesHelper)\nWireframeHelper = _ctor(api.WireframeHelper)\nXHRLoader = _ctor(api.XHRLoader)\nBinaryTextureLoader = _ctor(api.BinaryTextureLoader)\nGeometryUtils = _ctor(api.GeometryUtils)\nImageUtils = _ctor(api.ImageUtils)\nProjector = _ctor(api.Projector)\nCanvasRenderer = _ctor(api.CanvasRenderer)\n\n",
		"# Mersenne-Twister algorithm\n\n_array = [0 for i in range (624)]\n_index = 0\n_bitmask1 = (2 ** 32) - 1\n_bitmask2 = 2 ** 31\n_bitmask3 = (2 ** 31) - 1\n\ndef _fill_array():\n    global _array\n    for i in range (624):\n        y = (_array [i] & _bitmask2) + (_array [(i + 1) % 624] & _bitmask3)\n        _array [i] = _array [(i + 397) % 624] ^ (y >> 1)\n        if y % 2 != 0:\n            _array[i] ^= 2567483615\n            \ndef _random_integer ():\n    global _index\n    global _array\n    if _index == 0:\n        _fill_array ()\n    y = _array [_index]\n    y ^= y >> 11\n    y ^= (y << 7) & 2636928640\n    y ^= (y << 15) & 4022730752\n    y ^= y >> 18\n\n    _index = (_index + 1) % 624\n    return y\n\ndef seed (x = int (_bitmask3 * Math.random ())):\n    global _array\n    global _bitmask1\n    _array [0] = x\n    for i in  range (1, 624):\n        _array [i] = ((1812433253 * _array [i - 1]) ^ ((_array [i - 1] >> 30) + i)) & _bitmask1\n\ndef randint (a, b):\n    return a + _random_integer () % (b - a + 1)\n\ndef choice (seq):\n    return seq [randint (0, len (seq) - 1)]\n\ndef random ():\n    return _random_integer () / _bitmask3\n    \nseed ()\n",
		"# File: transcript/modules/re/__init__.py\n# Author: Carl Allendorph\n# Date: 13NOV2016\n#\n# Description:\n#    This file contains the definition of a simulated re python\n# regular expression parsing module. The idea is to leverage the\n# javascript native regular expression interface as much as\n# possible. In fact, where necessary, this module chooses the\n# javascript idiosyncracies over the python ones.\n#\n#\n\nfrom org.transcrypt.stubs.browser import __pragma__\nfrom re.translate import translate\n\n\n# Flags\n\nT = (1<<0)\nTEMPLATE = T\n\nI = (1<<1)\nIGNORECASE = I\n\n# Deprecated\nL = (1<<2)\nLOCALE = L\n\nM = (1<<3)\nMULTILINE = M\n\nS = (1 << 4)\nDOTALL = S\n# Legacy - Unicode by default in Python 3\nU = (1 << 5)\nUNICODE = U\nX = (1 << 6)\nVERBOSE = X\nDEBUG = (1<<7)\n\nA = (1<<8)\nASCII = A\n\n# This is a javascript specific flag\nY = (1 << 16)\nSTICKY = Y\nG = (1 << 17)\nGLOBAL = G\n# This flag is used to indicate that re module should use\n# the javascript regex engine directly and not attempt to\n# translate the regex string into a python regex\nJ = (1<<19)\nJSSTRICT = J\n\n\n\nclass error(Exception):\n    \"\"\" Regular Expression Exception Class\n    \"\"\"\n    def __init__(self, msg, error, pattern = None, flags = 0, pos = None):\n        \"\"\"\n        \"\"\"\n        Exception.__init__(self, msg, error=error)\n        self.pattern = pattern\n        self.flags = flags\n        self.pos = pos\n        # @todo - lineno and colno attributes\n\nclass ReIndexError(IndexError):\n    \"\"\" Index Error variant for the re module - primarily used for\n    the group method in the Match Object.\n    \"\"\"\n    def __init__(self):\n        IndexError.__init__(self, \"no such group\")\n\nclass Match(object):\n    \"\"\" Resulting Match from a Regex Operation\n    \"\"\"\n    def __init__(self, mObj, string, pos, endpos, rObj, namedGroups = None):\n        \"\"\"\n        \"\"\"\n        # JS has two \"None\" values: `null` and `undefined`.\n        # `x is None` converts to `x === null`, which will fail if `x` is undefined.\n        # The js match object uses undefined for non-used capture groups,\n        # so it's not possible to find non-used groups by comparing with `None`,\n        # unless this conversion is made.\n        for index, match in enumerate(mObj):\n            mObj[index] = None if mObj[index] == js_undefined else mObj[index]\n        self._obj = mObj\n\n        self._pos = pos\n        self._endpos = endpos\n        self._re = rObj\n        self._string = string\n\n        self._namedGroups = namedGroups\n\n        self._lastindex = self._lastMatchGroup()\n        if ( self._namedGroups is not None ):\n            self._lastgroup = self._namedGroups[self._lastindex]\n        else:\n            # @note - javascript does not have the concept\n            #       of named groups so we will never be able to\n            #       implement this in raw RegExp\n            self._lastgroup = None\n\n    # Read-only Properties\n    def _getPos(self):\n        return(self._pos)\n    def _setPos(self, val):\n        raise AttributeError(\"readonly attribute\")\n    pos = property(_getPos, _setPos)\n\n    def _getEndPos(self):\n        return(self._endpos)\n    def _setEndPos(self, val):\n        raise AttributeError(\"readonly attribute\")\n    endpos = property(_getEndPos, _setEndPos)\n\n    def _getRe(self):\n        return(self._re)\n    def _setRe(self, val):\n        raise AttributeError(\"readonly attribute\")\n    re = property(_getRe, _setRe)\n\n    def _getString(self):\n        return(self._string)\n    def _setString(self, val):\n        raise AttributeError(\"readonly attribute\")\n    string = property(_getString, _setString)\n\n    def _getLastGroup(self):\n        return(self._lastgroup)\n    def _setLastGroup(self, val):\n        raise AttributeError(\"readonly attribute\")\n    lastgroup = property(_getLastGroup, _setLastGroup)\n\n    def _getLastIndex(self):\n        return(self._lastindex)\n    def _setLastIndex(self, val):\n        raise AttributeError(\"readonly attribute\")\n    lastindex = property(_getLastIndex, _setLastIndex)\n\n    def _lastMatchGroup(self):\n        \"\"\" Determine the last matching group in the object\n        \"\"\"\n        if ( len(self._obj) > 1 ):\n            for i in range(len(self._obj)-1,0,-1):\n                if (self._obj[i] is not None):\n                    return(i)\n            # None of the capture groups matched -\n            # this seems like it shouldn't happen\n            return(None)\n        else:\n            # No Capture Groups\n            return(None)\n\n    def expand(self, template):\n        \"\"\"\n        \"\"\"\n        raise NotImplementedError()\n\n    def group(self, *args):\n        \"\"\" Return the string[s] for a group[s]\n        if only one group is provided, a string is returned\n        if multiple groups are provided, a tuple of strings is returned\n        \"\"\"\n        ret = []\n        if ( len(args) > 0 ):\n            for index in args:\n                if type(index) is str:\n                    if self._namedGroups is not None:\n                        if ( index not in self._namedGroups.keys() ):\n                            raise ReIndexError()\n                        ret.append( self._obj[self._namedGroups[index]] )\n                    else:\n                        raise NotImplementedError(\"No NamedGroups Available\");\n                else:\n                    if ( index >= len(self._obj) ):\n                        # js will return an 'undefined' and we\n                        # want this to return an index error\n                        # Built-in Exceptions not defined ?\n                        raise ReIndexError()\n                    ret.append(self._obj[index])\n        else:\n            ret.append(self._obj[0])\n\n        if ( len(ret) == 1 ):\n            return(ret[0])\n        else:\n            return(tuple(ret))\n\n    def groups(self, default = None):\n        \"\"\" Get all the groups in this match. Replace any\n        groups that did not contribute to the match with default\n        value.\n        \"\"\"\n        if ( len(self._obj) > 1 ):\n            ret = self._obj[1:]\n            return(tuple([x if x is not None else default for x in ret]))\n        else:\n            return(tuple())\n\n    def groupdict(self, default = None):\n        \"\"\" The concept of named captures doesn't exist\n        in javascript so this will likely never be implemented.\n        For the python translated re we will have a group dict where\n        possible.\n        \"\"\"\n        if ( self._namedGroups is not None ):\n            ret = {}\n            for gName, gId in self._namedGroups.items():\n                value = self._obj[gid]\n                ret[gName] = value if value is not None else default\n            return(ret)\n        else:\n            # JS Only does not implement this\n            raise NotImplementedError(\"No NamedGroups Available\")\n\n    def start(self, group = 0):\n        \"\"\" Find the starting index in the string for the passed\n        group id or named group string.\n        @param group\n          if the type of group is a str, then the named groups dict\n            is searched for a matching string.\n          if the type of group is an int, then the groups are\n            indexed starting with 0 = entire match, and 1,... are\n            the indices of the matched sub-groups\n        \"\"\"\n        gId = 0\n        if ( type(group) is str ):\n            if ( self._namedGroups is not None):\n                if ( group not in self._namedGroups.keys() ):\n                    raise ReIndexError()\n                gId = self._namedGroups[group]\n            else:\n                raise NotImplementedError(\"No NamedGroups Available\")\n        else:\n            gId = group\n\n        if ( gId >= len(self._obj) ):\n            raise ReIndexError()\n\n        if ( gId == 0 ):\n            return(self._obj.index)\n        else:\n            # We don't really have a good way to do\n            # this in javascript. so we will attempt\n            # to match the string we found as a\n            # sub position in the main string - this\n            # isn't perfect though because you could\n            # create a capture that only matches on\n            # the last in a group - this is a difficult\n            # problem to solve without completely\n            # re-writing the regex engine from scratch.\n            if ( self._obj[gId] is not None ):\n                r = compile(escape(self._obj[gId]), self._re.flags)\n                m = r.search(self._obj[0])\n                if m:\n                    return(self._obj.index + m.start())\n                else:\n                    raise Exception(\"Failed to find capture group\")\n            else:\n                # This capture did not contribute the match.\n                return(-1)\n\n    def end(self, group = 0):\n        \"\"\" Find the ending index in the string for the passed\n        group id or named group string.\n        @param group\n          if the type of group is a str, then the named groups dict\n            is searched for a matching string.\n          if the type of group is an int, then the groups are\n            indexed starting with 0 = entire match, and 1,... are\n            the indices of the matched sub-groups\n        \"\"\"\n        gId = 0\n        if ( type(group) is str ):\n            if ( self._namedGroups is not None):\n                if ( group not in self._namedGroups.keys() ):\n                    raise ReIndexError()\n                gId = self._namedGroups[group]\n            else:\n                raise NotImplementedError(\"No NamedGroups Available\")\n        else:\n            gId = group\n\n        if ( gId >= len(self._obj) ):\n            raise ReIndexError()\n\n        if ( gId == 0 ):\n            return( self._obj.index + len(self._obj[0]))\n        else:\n            # We don't really have a good way to do\n            # this in javascript. so we will attempt\n            # to match the string we found as a\n            # sub position in the main string - this\n            # isn't perfect though because you could\n            # create a capture that only matches on\n            # the last in a group - this is a difficult\n            # problem to solve without completely\n            # re-writing the regex engine from scratch.\n            if ( self._obj[gId] is not None ):\n                r = compile(escape(self._obj[gId]), self._re.flags)\n                m = r.search(self._obj[0])\n                if m:\n                    return(self._obj.index + m.end())\n                else:\n                    raise Exception(\"Failed to find capture group\")\n            else:\n                # This capture did not contribute the match.\n                return(-1)\n\n    def span(self, group = 0):\n        \"\"\" Find the start and end index in the string for the passed\n        group id or named group string.\n        @param group\n          if the type of group is a str, then the named groups dict\n            is searched for a matching string.\n          if the type of group is an int, then the groups are\n            indexed starting with 0 = entire match, and 1,... are\n            the indices of the matched sub-groups\n        @return tuple of (start, end)\n        \"\"\"\n        return( (self.start(group), self.end(group)) )\n\nclass Regex(object):\n    \"\"\" Regular Expression Object\n    \"\"\"\n    def __init__(self, pattern, flags):\n        \"\"\" Initial the Regex Object\n        @param pattern - javascript regular expression pattern as a string\n        @param flags - string of javascript flags for the subsequently\n           created RegExp object.\n        \"\"\"\n        if ( not ((flags & ASCII) > 0) ):\n            flags |= UNICODE\n\n        self._flags = flags\n        self._jsFlags, self._obj = self._compileWrapper(pattern, flags)\n        self._jspattern = pattern\n        # For this regex object pypattern and jspattern are the\n        # same.\n        self._pypattern = pattern\n\n        # we will determine groups by using another regex\n        # that tacks on an empty match.\n        _, groupCounterRegex = self._compileWrapper(pattern + '|', flags)\n        self._groups = groupCounterRegex.exec('').length-1\n        # Javascript does not have named captures so this\n        # will never have content in js only mode\n        self._groupindex = None\n\n    # Read-only Properties\n    def _getPattern(self):\n        ret = self._pypattern.replace('\\\\', '\\\\\\\\')\n        return(ret)\n    def _setPattern(self, val):\n        raise AttributeError(\"readonly attribute\")\n    pattern = property(_getPattern, _setPattern)\n\n    def _getFlags(self):\n        return(self._flags)\n    def _setFlags(self, val):\n        raise AttributeError(\"readonly attribute\")\n    flags = property(_getFlags, _setFlags)\n\n    def _getGroups(self):\n        return(self._groups)\n    def _setGroups(self, val):\n        raise AttributeError(\"readonly attribute\")\n    groups = property(_getGroups, _setGroups)\n\n    def _getGroupIndex(self):\n        if ( self._groupindex is None ):\n            return({})\n        else:\n            return(self._groupindex)\n    def _setGroupIndex(self, val):\n        raise AttributeError(\"readonly attribute\")\n    groupindex = property(_getGroupIndex, _setGroupIndex)\n\n    def _compileWrapper(self, pattern, flags = 0):\n        \"\"\" This function wraps the creation of the the\n        regular expresion so that we can catch the\n        Syntax Error exception and turn it into a\n        Python Exception\n        \"\"\"\n        jsFlags = self._convertFlags(flags)\n\n        rObj = None\n        errObj = None\n        # The Exceptions need to be converted to python exceptions\n        # in order to propagate appropriately\n        __pragma__('js', '{}',\n                   '''\n                   try {\n                     rObj = new RegExp(pattern, jsFlags)\n                   } catch( err ) {\n                     errObj = err\n                   }\n                   ''')\n\n        if ( errObj is not None ):\n            raise error(errObj.message, errObj, pattern, flags)\n\n        return(jsFlags, rObj)\n\n    def _convertFlags(self, flags):\n        \"\"\" Convert the Integer map based flags to a\n        string list of flags for js\n        \"\"\"\n        bitmaps = [\n            (DEBUG , \"\"),\n            (IGNORECASE, \"i\"),\n            (MULTILINE, \"m\"),\n            (STICKY, \"y\"),\n            (GLOBAL, \"g\"),\n            (UNICODE, \"u\"),\n        ]\n        ret = \"\".join( [x[1] for x in bitmaps if (x[0] & flags) > 0] )\n        return(ret)\n\n    def _getTargetStr(self, string, pos, endpos):\n        \"\"\" Given an start and endpos, slice out a target string.\n        \"\"\"\n        endPtr = len(string)\n        if ( endpos is not None ):\n            if ( endpos < endPtr):\n                endPtr = endpos\n        if ( endPtr < 0 ):\n            endPtr = 0\n        ret = string[pos:endPtr]\n        return(ret)\n\n    def _patternHasCaptures(self):\n        \"\"\" Check if the regex pattern contains a capture\n        necessary to make split behave correctly\n        \"\"\"\n        return(self._groups > 0)\n\n    def search(self, string, pos=0, endpos=None):\n        \"\"\" Search through a string for matches to\n        this regex object. @see the python docs\n        \"\"\"\n        if ( endpos is None ):\n            endpos = len(string)\n        # @note - pos/endpos don't operate like a slice\n        #       here - we need to search complete string and then\n        #       reject if the match happens outside of pos:endpos\n        rObj = self._obj\n        m = rObj.exec(string)\n        if m:\n            if ( m.index < pos or m.index > endpos ):\n                return(None)\n            else:\n                # Valid match we will create a match object\n                return( Match(m, string, pos, endpos, self, self._groupindex))\n        else:\n            return(None)\n\n    def match(self, string, pos=0, endpos = None):\n        \"\"\" Match this regex at the beginning of the passed\n        string. @see the python docs\n        \"\"\"\n        target = string\n        if ( endpos is not None ):\n            target = target[:endpos]\n        else:\n            endpos = len(string)\n\n        rObj = self._obj\n        m = rObj.exec(target)\n        if m:\n            # Match only at the beginning\n            if ( m.index == pos ):\n                return( Match(m, string, pos, endpos, self, self._groupindex))\n            else:\n                return(None)\n        else:\n            return(None)\n\n    def fullmatch(self, string, pos=0, endpos = None):\n        \"\"\" Match the entirety of the passed string to this regex\n        object. @see the python docs\n        \"\"\"\n        target = string\n        strEndPos = len(string)\n        if ( endpos is not None ):\n            target = target[:endpos]\n            strEndPos = endpos\n\n        rObj = self._obj\n        m = rObj.exec(target)\n        if m:\n            obsEndPos = (m.index+len(m[0]))\n            if ( m.index == pos and obsEndPos == strEndPos ):\n                return( Match(m, string, pos, strEndPos, self, self._groupindex))\n            else:\n                return(None)\n        else:\n            return(None)\n\n    def split(self, string, maxsplit = 0):\n        \"\"\" Split the passed string on each match of this regex\n        object. If the regex contains captures, then the match\n        content is included as a separate item. If no captures are\n        in the regex, then only the non-matching split content is\n        returned. @see the python docs\n        @param maxsplit max number of times to split the string\n          at a matching substring.\n        @return list of sub-strings\n        \"\"\"\n        # JS split is slightly different from Python\n        # the \"limit\" arg limits the number of elements\n        # returned in the list - it doesn't limit the number of\n        # splits.\n\n        if ( maxsplit < 0 ):\n            return([string])\n\n        mObj = None\n        rObj = self._obj\n        if ( maxsplit == 0 ):\n            mObj = string.split(rObj)\n            return(mObj)\n        else:\n            # the split limit parameter in js does not behave like\n            # the maxsplit parameter in python - hence we need to\n            # do this manually.\n            # @todo - make this better handle the flags\n            flags = self._flags\n            flags |= GLOBAL\n\n            _, rObj = self._compileWrapper(self._jspattern, flags)\n            ret = []\n            lastM = None\n            cnt = 0\n            for i in range(0, maxsplit):\n                m = rObj.exec(string)\n                if m:\n                    cnt += 1\n                    if ( lastM is not None ):\n                        # subsequent match\n                        start = lastM.index + len(lastM[0])\n                        head = string[start:m.index]\n                        ret.append(head)\n                        if ( len(m) > 1 ):\n                            ret.extend(m[1:])\n                    else:\n                        # First match\n                        head = string[:m.index]\n                        ret.append(head)\n                        if ( len(m) > 1 ):\n                            ret.extend(m[1:])\n                    lastM = m\n                else:\n                    break\n\n            if ( lastM is not None ):\n                endPos = lastM.index + len(lastM[0])\n                end = string[endPos:]\n                ret.append(end)\n\n            return(ret)\n\n    def _findAllMatches(self, string, pos = 0, endpos = None):\n        target = self._getTargetStr(string, pos, endpos)\n\n        # Unfortunately, js RegExp.match does not behave\n        # like findall behaves in python - it doesn't\n        # pull out 'captures' like python expects so we\n        # are going to use RegExp.exec instead of match\n        flags = self._flags\n        flags |= GLOBAL\n\n        _, rObj = self._compileWrapper(self._jspattern, flags)\n        ret = []\n        while( True ):\n            m = rObj.exec(target)\n            if m:\n                ret.append(m)\n            else:\n                break\n        return(ret)\n\n    def findall(self, string, pos = 0, endpos = None):\n        \"\"\" Find All the matches to this regex in the passed string\n        @return either:\n          List of strings of the matched regex has 1 or 0 capture\n            groups\n          List of elements that are each a list of the groups matched\n            at each location in the string.\n        @see the python docs\n        \"\"\"\n        mlist = self._findAllMatches(string, pos, endpos)\n\n        def mSelect(m):\n            if ( len(m) > 2 ):\n                # Captures Present and we need to\n                # convert to a tuple\n                return(tuple(m[1:]))\n            elif ( len(m) == 2 ):\n                # 1 Capture\n                return(m[1])\n            else:\n                # No captures\n                return(m[0])\n\n        ret = map(mSelect, mlist)\n\n        return(ret)\n\n    def finditer(self, string, pos, endpos = None):\n        \"\"\" Like findall but returns an iterator instead of\n        a list.\n        @see the python docs\n        \"\"\"\n        # @note - Transcrypt compiled with `-e 5` does not have\n        #    iterator support at this point. Only `-e 6` has\n        #    iterator support.\n        __pragma__ ('ifdef', '__esv5__')\n        raise NotImplementedError(\"No Iterator Support in es5\")\n        __pragma__('else')\n        mlist = self._findAllMatches(string, pos, endpos)\n        ret = map(lambda m: Match(m, string, 0, len(string), self, self._groupindex), mlist)\n        return( iter(ret) )\n        __pragma__('endif')\n\n    def sub(self, repl, string, count = 0):\n        \"\"\" Substitude each match of this regex in the passed string\n        with either:\n          if repl is of type string,\n             replace with repl\n          if repl is a callable object, then the returned value\n            from repl(m) where m is the match object at a particular\n            point in the string.\n        @see the python docs\n        @return the augmented string with substitutions\n        \"\"\"\n        ret,_ = self.subn(repl, string, count)\n        return(ret)\n\n    def subn(self, repl, string, count = 0):\n        \"\"\" Similar to sub except that instead of just returning the\n        augmented string, it returns a tuple of the augmented string\n        and the number of times that the replacement op occured.\n        (augstr, numreplacements)\n        @see the python docs\n        \"\"\"\n        # For this we are going to use the 'exec' method\n        # because the 'replace' method in javascript is broken\n        # for what we are trying do. There is no way to get\n        # the function callback concept to work.\n        flags = self._flags\n        flags |= GLOBAL\n\n        _, rObj = self._compileWrapper(self._jspattern, flags)\n        ret = \"\"\n        totalMatch = 0\n        lastEnd = -1\n        while(True):\n            if (count > 0):\n                if ( totalMatch >= count ):\n                    if ( lastEnd < 0 ):\n                        # This is an odd case - if we got\n                        # here it means there is a bug in our code.\n                        return(ret,totalMatch)\n                    else:\n                        ret += string[lastEnd:m.index]\n                        return(ret,totalMatch)\n\n            m = rObj.exec(string)\n            if m:\n                if ( lastEnd < 0 ):\n                    # first match\n                    ret += string[:m.index]\n                else:\n                    # subsequent match\n                    ret += string[lastEnd:m.index]\n\n                if callable(repl):\n                    content = repl(Match(m, string, 0, len(string), self, self._groupindex))\n                    ret += content\n                else:\n                    ret += repl\n\n                totalMatch+=1\n                # Update the last end so we know where to start\n                # copying from on the next pass\n                lastEnd = m.index + len(m[0])\n            else:\n                # Failed to match means that there are no more\n                # matches in the string\n                if ( lastEnd < 0 ):\n                    # No matches were found - we return string\n                    # unmolested\n                    return(string, 0)\n                else:\n                    ret += string[lastEnd:]\n                    return(ret,totalMatch)\n\n\nclass PyRegExp(Regex):\n    \"\"\" Python Regular Expression object which translates a python\n    regex syntax string into a format that can be passed to the\n    js regex engine.\n    \"\"\"\n    def __init__(self, pyPattern, flags):\n        \"\"\"\n        @pattern Python Regex String\n        @pattern flags bit flags passed by the user.\n        \"\"\"\n        jsTokens, inlineFlags, namedGroups, nCapGroups, n_splits = translate(pyPattern)\n        flags |= inlineFlags\n\n        jsPattern = ''.join(jsTokens)\n        Regex.__init__(self, jsPattern, flags)\n        self._pypattern = pyPattern\n\n        self._nsplits = n_splits\n        self._jsTokens = jsTokens\n        # nCapGroups = the same as self.groups defined in the\n        #   base class.\n        self._capgroups = nCapGroups\n        self._groupindex = namedGroups\n\ndef compile(pattern, flags = 0):\n    \"\"\" Compile a regex object and return\n    an object that can be used for further processing.\n    \"\"\"\n    if ( flags & JSSTRICT ):\n        p = Regex(pattern, flags)\n    else:\n        p = PyRegExp(pattern, flags)\n    return(p)\n\ndef search(pattern, string, flags = 0):\n    \"\"\" Search a string for a particular matching pattern\n    \"\"\"\n    p = compile(pattern, flags)\n    return( p.search(string) )\n\ndef match(pattern, string, flags = 0):\n    \"\"\" Match a string for a particular pattern\n    \"\"\"\n    p = compile(pattern, flags)\n    return( p.match(string) )\n\ndef fullmatch(pattern, string, flags = 0):\n    \"\"\"\n    \"\"\"\n    p = compile(pattern, flags)\n    return( p.fullmatch(string) )\n\ndef split(pattern, string, maxsplit = 0, flags = 0):\n    \"\"\"\n    \"\"\"\n    p = compile(pattern, flags)\n    return( p.split(string, maxsplit) )\n\ndef findall(pattern, string, flags = 0):\n    \"\"\"\n    \"\"\"\n    p = compile(pattern, flags)\n    return( p.findall(string) )\n\ndef finditer(pattern, string, flags = 0):\n    \"\"\"\n    \"\"\"\n    p = compile(pattern, flags)\n    return( p.finditer(string) )\n\ndef sub(pattern, repl, string, count = 0, flags = 0):\n    \"\"\"\n    \"\"\"\n    p = compile(pattern, flags)\n    return( p.sub(repl, string, count) )\n\ndef subn(pattern, repl, string, count = 0, flags = 0):\n    \"\"\"\n    \"\"\"\n    p = compile(pattern, flags)\n    return( p.subn(repl, string, count) )\n\ndef escape(string):\n    \"\"\" Escape a passed string so that we can send it to the\n    regular expressions engine.\n    \"\"\"\n    ret = None\n    def replfunc(m):\n        if ( m[0] == \"\\\\\" ):\n            return(\"\\\\\\\\\\\\\\\\\")\n        else:\n            return(\"\\\\\\\\\" + m[0])\n\n    # @note - I had an issue getting replfunc to be called in\n    #        javascript correctly when I didn't use this pragma\n    #        not sure if I was just doing it wrong or what\n    __pragma__(\n        'js', '{}',\n        '''\n        var r = /[^A-Za-z\\d]/g;\n        ret = string.replace(r, replfunc);\n        ''')\n    if ( ret is not None ):\n        return(ret)\n    else:\n        raise Exception(\"Failed to escape the passed string\")\n\ndef purge():\n    \"\"\" I think this function is unnecessary but included to keep interface\n    consistent.\n    \"\"\"\n    pass\n",
		"# Python RegExp Syntax to Javascript RegExp Syntax Translator\n# This code was pulled from the repository at:\n#   https://github.com/GULPF/rescrypt\n# Original license was MIT but was converted to Apache v2 for\n# ease of integrating with the Transcrypt project\n#\n\n\n__pragma__ ('tconv')\n\nVERBOSE = False\n\nMAX_SHIFTREDUCE_LOOPS = 1000\n\nstringFlags = 'aiLmsux'\n\n# Represents a regex group (e.g /()/, /(?:)/ /(?=), etc).\n# `start` and `end` is the index of the groups start and end token in the token list.\nclass Group:\n    def __init__(self, start, end, klass):\n        self.start = start\n        self.end = end\n        self.klass = klass\n\n    def __repr__(self):\n        return str((self.start, self.end, self.klass))\n\n\n# Generates a list of `Group`s from a token list.\ndef generateGroupSpans(tokens):\n    groupInfo = []\n\n    idx = 0\n    for token in tokens:\n        if token.name.startswith('('):\n            groupInfo.append(Group(idx, None, token.name))\n        elif token.name == ')':\n            for group in reversed(groupInfo):\n                if group.end is None:\n                    group.end = idx\n        idx += 1\n    return groupInfo\n\n\ndef countCaptureGroups(tokens):\n    groupInfo = generateGroupSpans(tokens)\n    count = 0\n\n    for token in tokens:\n        if token.name == '(':\n            count += 1\n\n    return count\n\n\n# Get the `Group` for a capture group with a given id or name.\ndef getCaptureGroup(groupInfo, namedGroups, groupRef):\n    try:\n        id = int(groupRef)\n    except:\n        id = namedGroups[groupRef]\n    search = 0\n    for group in groupInfo:\n        if group.klass == '(':\n            search += 1\n            if search == id:\n                return group\n\n\n# Regex conditionals is implemented by splitting the regex into two parts,\n# one for the if case and one for the else case.\n# Example: if the input is (a)?(b)?(?(1)a|c)(?(2)b|d),\n# the first conditional will cause it to split into these parts:\n# `()(b)?c(?(2)b|d)` and `(a)(b)?a(?(2)b|d)`\n# The second conditional will then cause each part to split into two, creating four parts in total:\n# `()()cd`, `()(b)cb`, `(a)()ad` and `(a)(b)ab`\n# The parts are then merged into a single regex: `part1|part2|part3|part4`.\n# TODO: This causes the group indexes to be messed up. To fix it, group indexes must be modified with `% len(groups) + 1`.\ndef splitIfElse(tokens, namedGroups):\n    variants = []\n    groupInfo = generateGroupSpans(tokens)\n\n    for group in groupInfo:\n        if group.klass == '(?<':\n            iff = tokens[:]\n            els = tokens[:]\n            conStart = group.start\n            conEnd   = group.end\n\n            ref = tokens[conStart + 1].name\n            captureGroup = getCaptureGroup(groupInfo, namedGroups, ref)\n            captureGroupModifier = tokens[captureGroup.end + 1]\n\n            if captureGroupModifier.name in ['?', '*'] or captureGroupModifier.name.startswith('{0,'):\n                if captureGroupModifier.name == '?':\n                    iff[captureGroup.end + 1] = None\n                elif captureGroupModifier.name == '*':\n                    iff[captureGroup.end + 1] = Token('+')\n                elif captureGroupModifier.name.startswith('{0,'):\n                    iff[captureGroup.end + 1].name[0:3] = '{1,'\n                els[captureGroup.end + 1] = None\n\n                hasElse = False\n                for idx in range(conStart, conEnd):\n                    if tokens[idx].name == '|':\n                        hasElse = True\n                        els.pop(conEnd)\n                        iff[idx:conEnd + 1] = []\n                        els[conStart:idx + 1] = []\n                        break\n\n                if not hasElse:\n                    els[conStart:conEnd + 1] = []\n                    iff.pop(conEnd)\n\n                iff[conStart:conStart + 3] = []\n                els[captureGroup.start:captureGroup.end + 1] = [Token('('), Token(')')]\n                iff.remove(None)\n                els.remove(None)\n                variants.append(iff)\n                variants.append(els)\n\n            else:  # the easy case - 'else' is impossible\n                pastIff = False\n                for idx in range(conStart, conEnd):\n                    if iff[idx].name == '|':\n                        iff = tokens[:idx]\n                        iff.extend(tokens[conEnd + 1:])\n                        break\n                iff[conStart:conStart + 3] = []\n                variants.append(iff)\n            break\n\n    if not variants:\n        return [tokens]\n\n    allVariants = []\n    for variant in variants:\n        allVariants.extend(splitIfElse(variant, namedGroups))\n    return allVariants\n\n\nclass Token:\n    def __init__(self, name, paras=None, pure=False):\n        if paras is None:\n            paras = []\n        self.name  = name\n        self.paras = paras\n        self.pure = pure\n        # tmp until I have thought of something better\n        self.isModeGroup = False\n\n    def __repr__(self):\n        return self.name\n\n    def resolve(self):\n        paras = ''\n        for para in self.paras:\n            paras += str(para)\n\n        return self.name + paras\n\n\ndef shift(stack, queue):\n    done = not bool(queue)\n    if not done:\n        stack.append(Token(queue[0], [], True))\n        queue = queue[1:]\n    return stack, queue, done\n\n\n# Shift-reduce parser. Creates the next state of the stack & queue.\ndef shiftReduce(stack, queue, namedGroups, flags):\n    done = False\n    high = len(stack) - 1\n\n    if len(stack) < 2:\n        stack, queue, done = shift(stack, queue)\n        return stack, queue, flags, done\n\n    s0 = stack[high]     if len(stack) > 0 else Token('')\n    s1 = stack[high - 1] if len(stack) > 1 else Token('')\n\n    if VERBOSE:\n        for token in stack:\n            console.log(token.resolve(), '\\t', end='')\n        console.log('')\n\n    if s1.name == '\\\\':\n        if s0.name == 'A':\n            stack[-2:] = [Token('^')]\n\n        elif s0.name == 'a':\n            stack[-2:] = [Token('\\\\07')]\n\n        elif s0.name == 'Z':\n            stack[-2:] = [Token('$')]\n\n        else:\n            stack[-2:] = [Token('\\\\' + s0.name)]\n\n    elif s0.name == '$' and s0.pure:\n        stack.pop()\n        stack.extend([Token('(?='), Token('\\\\n'), Token('?'), Token('$'), Token(')')])\n\n    elif s1.name == '{':\n        if s0.name == ',' and len(s1.paras) == 0:\n            s1.paras.append('0')\n            s1.paras.append(',')\n        else:\n            if s0.name == '}':\n                s1.paras.append('}')\n                s1.name = s1.resolve()\n                s1.paras = []\n            else:\n                s1.paras.append(s0.name)\n\n        stack = stack[:-1]\n\n    elif s1.name == '[' and s0.name == '^':\n        stack[-2:] = [Token('[^')]\n\n    elif s1.name == '(' and s0.name == '?':\n        stack[-2:] = [Token('(?')]\n\n    elif s1.name in ['*', '+', '?'] and s0.name == '?':\n        stack[-2:] = [Token(s1.name + '?')]\n\n    elif s1.isModeGroup and s0.name == ')':\n        stack = stack[:-2]\n\n    elif s1.name == '(?':\n        if s0.name in stringFlags:\n            if s0.name == 'i':\n                flags |= re.IGNORECASE\n            elif s0.name == 'L':\n                flags |= re.LOCALE\n            elif s0.name == 'm':\n                flags |= re.MULTILINE\n            elif s0.name == 's':\n                flags |= re.DOTALL\n            elif s0.name == 'u':\n                flags |= re.UNICODE\n            elif s0.name == 'x':\n                flags |= re.VERBOSE\n            elif s0.name == 'a':\n                flags |= re.ASCII\n\n            stack.pop()\n            s1.isModeGroup = True\n\n        else:\n            if s0.name == '(':\n                s0.name = '<'\n\n            newToken = Token('(?' + s0.name)\n            stack[-2:] = [newToken]\n\n    elif s1.name == '(?<':\n        if s0.name == ')':\n            stack[-1:] = [Token(''.join(s1.paras)), Token('>')]\n            s1.paras = []\n        else:\n            s1.paras.append(s0.name)\n            stack.pop()\n\n    elif s1.name == '(?P':\n        stack[-2:] = [Token('(?P' + s0.name)]\n\n    elif s1.name == '(?P<':\n        if s0.name == '>':\n            # todo: don't count every time, just keep track of it over time\n            namedGroups[''.join(s1.paras)] = countCaptureGroups(stack) + 1\n            stack[-2:] = [Token('(')]\n        else:\n            s1.paras.append(s0.name)\n            stack.pop()\n\n    elif s1.name == '(?P=':\n        if s0.name == ')':\n            stack[-2:] = [Token('\\\\' + str(namedGroups[s1.paras[0]]))]\n        elif not s1.paras:\n            s1.paras.append(s0.name)\n            stack.pop()\n        else:\n            s1.paras[0] += s0.name\n            stack.pop()\n\n    elif s1.name == '(?#':\n        if s0.name == ')':\n            stack = stack[:-2]\n        else:\n            stack = stack[:-1]\n\n    else:\n        stack, queue, done = shift(stack, queue)\n\n    return stack, queue, flags, done\n\n\n# Takes a re-regex and returns a js-regex.\n# TODO: Returns way to many values.\ndef translate(rgx):\n    # can't import as normal because it's a circular dependency\n    import re\n    stack = []\n    queue = list(rgx)\n\n    flags = 0\n    namedGroups = dict()\n\n    nloop = 0\n\n    while True:\n        nloop += 1\n        if nloop > MAX_SHIFTREDUCE_LOOPS:\n            raise Exception()\n\n        stack, queue, flags, done = shiftReduce(stack, queue, namedGroups, flags)\n        if done:\n            break\n\n    variants = splitIfElse(stack, namedGroups)\n    n_splits = len(variants)\n\n    final = []\n    for i in range(0, len(variants)):\n        final.extend(variants[i])\n        if i < len(variants) - 1:\n            final.append(Token('|'))\n    stack = final\n\n    groupInfo = generateGroupSpans(stack)\n    resolvedTokens = []\n\n    for token in stack:\n        stringed = token.resolve()\n        if (flags & re.DOTALL) and stringed == '.':\n            stringed = '[\\s\\S]'\n        resolvedTokens.append(stringed)\n    return resolvedTokens, flags, namedGroups, countCaptureGroups(stack), n_splits\n",
		"\"\"\"\ntime module\n\nNo:\n\n- Platform specific functions\n- sleep. In js currently not possible in browsers\n         except via busy loops, we don't do that.\n- struct_time CLASS. we work only via the tuple interface of it.\n- handling of weird stuff.\n    e.g.: In Europe/Simferopool (Ukraine) the UTC offset before 1924 was +2.67\n\nSpec for all below (must have open to read this module):\n\n> https://docs.python.org/3.5/library/time.html\n\n\nJul 2016, Gunther Klessinger, Axiros GmbH\n\"\"\"\n# we don't need those:\n__pragma__ ('nokwargs')\n\n\n# for js dates:\nfrom org.transcrypt.stubs.browser import __new__\n\n# js date object. might be modified during calculations:\n__date = __new__(Date(0))\n__now = __new__(Date())\n\n\n# build the locale's weekday names\n__weekdays = []\n__weekdays_long = []\n__d = __new__(Date(1467662339080)) # a monday\nfor i in range(7):\n    for l, s in (__weekdays, 'short'), (__weekdays_long, 'long'):\n        l.append(__d.toLocaleString(window.navigator.language,\n                                        {'weekday': s}).lower())\n    __d.setDate(__d.getDate() + 1)\n\n\n# build the locale's months names\n__months = []\n__months_long = []\n__d = __new__(Date(946681200000.0)) # 1.1.2000\nfor i in range(12):\n    for l, s in ((__months, 'short'), (__months_long, 'long')):\n        l.append(__d.toLocaleString(window.navigator.language,\n                                        {'month': s}).lower())\n    __d.setMonth(__d.getMonth() + 1)\n\n\n\n# lookup for positions directives in struct_time tuples:\n# its a 9-sequence\n#        time.struct_time(tm_year=2016, tm_mon=7, tm_mday=19, tm_hour=2,\n#                         tm_min=24, tm_sec=2, tm_wday=1, tm_yday=201,\n#                         tm_isdst=1)\n__lu = {'Y': 0, 'm': 1, 'd': 2, 'H': 3, 'M': 4, 'S': 5}\n\ndef _lsplit(s, sep, maxsplit):\n    \"\"\" not yet in TS \"\"\"\n    if maxsplit == 0:\n        return [s]\n    split = s.split(sep)\n    if not maxsplit:\n        return split\n    ret = split.slice(0, maxsplit, 1)\n    if len(ret) == len(split):\n        return ret\n    ret.append(sep.join(split[maxsplit:]))\n    return ret\n\n\ndef _local_time_tuple(jd):\n    \"\"\" jd: javascript Date object, from unixtimestamp \"\"\"\n    res =  ( jd.getFullYear()\n            ,jd.getMonth() + 1 # zero based\n            ,jd.getDate()\n            ,jd.getHours()\n            ,jd.getMinutes()\n            ,jd.getSeconds()\n            ,jd.getDay() - 1 if jd.getDay() > 0 else 6\n            ,_day_of_year(jd, True)\n            ,_daylight_in_effect(jd)\n            ,jd.getMilliseconds() # not in use by the pub API\n           )\n    return res\n\ndef _utc_time_tuple(jd):\n    \"\"\" jd: javascript Date object, from unixtimestamp \"\"\"\n    res =  ( jd.getUTCFullYear()\n            ,jd.getUTCMonth() + 1 # zero based\n            ,jd.getUTCDate()\n            ,jd.getUTCHours()\n            ,jd.getUTCMinutes()\n            ,jd.getUTCSeconds()\n            ,jd.getUTCDay() - 1\n            ,_day_of_year(jd, False)\n            ,0 # is dst for utc: 0\n            ,jd.getUTCMilliseconds()\n           )\n    return res\n\ndef _day_of_year(jd, local):\n    # check if jd hours are ahead of UTC less than the offset to it:\n    day_offs = 0\n    if jd.getHours() + jd.getTimezoneOffset() * 60 / 3600 < 0:\n        day_offs = -1\n    was = jd.getTime()\n    cur = jd.setHours(23)\n    jd.setUTCDate(1)\n    jd.setUTCMonth(0)\n    jd.setUTCHours(0)\n    jd.setUTCMinutes(0)\n    jd.setUTCSeconds(0)\n    res = round((cur - jd) / 86400000 )\n    #res = round(((jd.setHours(23) - new Date(jd.getYear(), 0, 1, 0, 0, 0)\n    #                 ) / 1000 / 60 / 60 / 24))\n    if not local:\n        res += day_offs\n\n    if res == 0:\n        res = 365\n        jd.setTime(jd.getTime() - 86400)\n        last_year = jd.getUTCFullYear()\n        if _is_leap(last_year):\n            res = 366\n    jd.setTime(was)\n    return res\n\ndef _is_leap(year):\n    return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)\n\ndef __jan_jun_tz(t, func):\n    \"\"\" information about local jan and jun month of a t's year\n    default is to deliver timezone offset, but a function can be handed to us,\n    which we'll run on those two months\n    \"\"\"\n    # required to detect dst (daylight saving time) in effect:\n    was = t.getTime() # avoid new date objs\n    t.setDate(1)\n    res = []\n    for m in 0, 6:\n        t.setMonth(m)\n        if not func:\n            res.append(t.getTimezoneOffset())\n        else:\n            res.append(func(t))\n    t.setTime(was)\n    return res\n\ndef _daylight(t):\n    \"\"\"\n    http://stackoverflow.com/questions/11887934/\n    check-if-daylight-saving-time-is-in-effect-and-if-it-is-for-how-many-hours\n\n    return 0 or 1 like python\n    CAUTION: https://docs.python.org/2/library/time.html#time.daylight:\n    \"Nonzero if a DST timezone is DEFINED.\" (but not necessarily in effect!!)\n    -> we just check if there is a delta of tz offsets in june an jan of the\n    year of t:\n    \"\"\"\n    jj = __jan_jun_tz(t)\n    if jj[0] != jj[1]:\n        # daylight saving is DEFINED, since there's a difference in tz offsets\n        # in jan and jun, in the year of t:\n        return 1\n    return 0\n\ndef _daylight_in_effect(t):\n    jj = __jan_jun_tz(t)\n    if min(jj[0], jj[1]) == t.getTimezoneOffset():\n        return 1\n    return 0\n\ndef _timezone(t):\n    jj = __jan_jun_tz(t)\n    # in southern hemisphere the daylight saving is in winter months!\n    return max(jj[0], jj[1])\n\n\ndef __tzn(t):\n    # depending on browser ? new Date() -> Wed Jul... (CEST)\n    try:\n        return str(t).split('(')[1].split(')')[0]\n    except:\n        # better no crash:\n        return 'n.a.'\n\ndef _tzname(t):\n    '''the first is the name of the local non-DST timezone,\n\tthe second is the name of the local DST timezone.'''\n    cn = __tzn(t)\n    ret = [cn, cn]\n    jj = __jan_jun_tz(t, __tzn)\n    ind = 0\n    if not _daylight_in_effect(t):\n        ind = 1\n    for i in jj:\n        if i != cn:\n            ret[ind] = i\n    return tuple(ret)\n\n\n\n\n# ------------------------------------------------------------------ Public API\n\n# we calc those only once. I mean - we run in the browser in the end.\n\naltzone = __now.getTimezoneOffset()\nif not _daylight_in_effect(__now):\n    # then we must use the other offset we have in the current year:\n    _jj  = __jan_jun_tz(__now)\n    altzone = _jj[0] if altzone == _jj[1] else _jj[1]\naltzone = altzone * 60\n\ntimezone = _timezone(__now) * 60\n\ndaylight = _daylight(__now)\n\ntzname   = _tzname(__now)\n\n\ndef time():\n    \"\"\"\n    time() -> floating point number\\n\\nReturn the current time in seconds\n    since the Epoch.\n    Fractions of a second may be present if the system clock provides them.\n    \"\"\"\n    return Date.now() / 1000\n\n\ndef asctime(t):\n    return strftime('%a %b %d %H:%M:%S %Y', t)\n\n\ndef mktime(t):\n    ''' inverse of localtime '''\n    d = __new__(Date(t[0], t[1] - 1, t[2], t[3], t[4], t[5], 0))\n    return (d - 0) / 1000\n\n\ndef ctime(seconds):\n    \"\"\"\n    ctime(seconds) -> string\n\n    Convert a time in seconds since the Epoch to a string in local time.\n    This is equivalent to asctime(localtime(seconds)). When the time tuple is\n    not present, current time as returned by localtime() is used.'\n    \"\"\"\n    if not seconds:\n        seconds = time()\n    return asctime(localtime(seconds))\n\n\ndef localtime(seconds):\n    \"\"\"\n    localtime([seconds]) -> (tm_year,tm_mon,tm_mday,tm_hour,tm_min,\n                          tm_sec,tm_wday,tm_yday,tm_isdst)\n\n    Convert seconds since the Epoch to a time tuple expressing local time.\n    When 'seconds' is not passed in, convert the current time instead.\n    \"\"\"\n    if not seconds:\n        seconds = time()\n    return gmtime(seconds, True)\n\n\ndef gmtime(seconds, localtime):\n    \"\"\"\n    localtime([seconds]) -> (tm_year,tm_mon,tm_mday,tm_hour,tm_min,\n                          tm_sec,tm_wday,tm_yday,tm_isdst)\n\n    Convert seconds since the Epoch to a time tuple expressing local time.\n    When 'seconds' is not passed in, convert the current time instead.\n    \"\"\"\n    if not seconds:\n        seconds = time()\n    millis = seconds * 1000\n    __date.setTime(millis)\n    if localtime:\n        t = _local_time_tuple(__date)\n    else:\n        t = _utc_time_tuple(__date)\n    return t[:9]\n\n# ----------------------------------------------------------------------------\n# now the workhorses:\ndef strptime(string, format):\n    \"\"\"\n    strptime(string, format) -> struct_time\n\n    Parse a string to a time tuple according to a format specification.\n    See the library reference manual for formatting codes (same as\n            strftime()).\n\n    Commonly used format codes:\n\n        %Y  Year with century as a decimal number.\n        %m  Month as a decimal number [01,12].\n        %d  Day of the month as a decimal number [01,31].\n        %H  Hour (24-hour clock) as a decimal number [00,23].\n        %M  Minute as a decimal number [00,59].\n        %S  Second as a decimal number [00,61].\n        %z  Time zone offset from UTC.\n        %a  Locale's abbreviated weekday name.\n        %A  Locale's full weekday name.\n        %b  Locale's abbreviated month name.\n        %B  Locale's full month name.\n        %c  Locale's appropriate date and time representation.\n        %I  Hour (12-hour clock) as a decimal number [01,12].\n        %p  Locale's equivalent of either AM or PM.\n\n        Tradoffs of this Transcrypt implementation:\n\n        1. platform specific codes not supported\n        2. %% and %c not supported\n        \"\"\"\n\n    if not format:\n        format = \"%a %b %d %H:%M:%S %Y\"\n    ts, fmt = string, format\n    def get_next(fmt):\n        ''' returns next directive, next seperator, rest of format str'''\n        def get_sep(fmt):\n            res = []\n            if not fmt:\n                return '', ''\n            for i in range(len(fmt)-1):\n                c = fmt[i]\n                if c == '%':\n                    break\n                res.append(c)\n            return ''.join(res), fmt[i:]\n\n        # return next seperator:\n        d, sep, f = None, None, None\n        if fmt:\n            if fmt[0] == '%':\n                d = fmt[1]\n                sep, f = get_sep(fmt[2:])\n            else:\n                sep, f = get_sep(fmt)\n        return d, sep, f\n\n    # directive / value tuples go in here:\n    dir_val = {}\n    while ts:\n        d, sep, fmt = get_next(fmt)\n        if sep == '':\n            lv = None\n            if d:\n                # we have a directive, seperator is empty. Is the directive\n                # fixed length, with next w/o sep? e.g. %Y%Z ?\n                # then get the next one like:\n                l = -1\n                if   d == 'Y': l = 4\n                elif d == 'a': l = len(__weekdays[0])\n                elif d == 'A': l = len(__weekdays_long[0])\n                elif d == 'b': l = len(__months[0])\n                elif d in ('d', 'm', 'H', 'M', 'S'):\n                    l = 2\n                if l > -1:\n                    lv = [ts[:l], ts[l:]]\n            if not lv:\n                lv = [ts, '']\n        else:\n            lv = _lsplit(ts, sep, 1)\n        if d == None:\n            ts = lv[1]\n            continue\n        ts, dir_val[d] = lv[1], lv[0]\n        if fmt == '':\n            break\n    # defaults when not specified:\n    t = [1900, 1, 1, 0, 0, 0, 0, 1, -1]\n    ignore_keys = []\n    have_weekday = False\n    for d, v in dir_val.items():\n        if d in ignore_keys:\n            continue\n\n        if d == 'p':\n            continue\n\n        if d in __lu.keys():\n            t[__lu[d]] = int(v)\n            continue\n\n        if d in ('a', 'A', 'b', 'B'):\n            v = v.lower()\n\n        if d == 'm':\n            # we go the python 2(!) way for conflicting %b %m and take %m\n            # why? because there IS no Py3 way (see strp time testlet)\n            ignore_keys.append('b')\n            ignore_keys.append('B')\n\n        # better readable than short:\n        if d == 'a':\n            # funny. the weekday is only set but does not override %d.\n            # -> produces impossible dates but well its how py does it:\n            if not v in __weekdays:\n                raise ValueError('Weekday unknown in your locale')\n            have_weekday = True\n            t[6] = __weekdays.index(v)\n\n        elif d == 'A':\n            if not v in __weekdays_long:\n                raise ValueError('Weekday unknown in your locale')\n            have_weekday = True\n            t[6] = __weekdays_long.index(v)\n\n        elif d == 'b':\n            # month short. overruled by m if present\n            if not v in __months:\n                raise ValueError('Month unknown in your locale')\n            t[1] = __months.index(v) + 1\n\n        elif d == 'B':\n            # month long. overruled by m if present\n            if not v in __months_long:\n                raise ValueError('Month unknown in your locale')\n            t[1] = __months_long.index(v) + 1\n\n\n        elif d == 'I':\n            # 0-12 hour, with AM/PM.\n            ampm = dir_val['p'] or 'am'\n            ampm = ampm.lower()\n            v = int(v)\n            # thats how py does it\n            if v == 12:\n                v = 0\n            elif v > 12:\n                raise ValueError(\"time data '\" + string + \\\n                        \"' does not match format '\" + format + \"'\")\n            if ampm == 'pm':\n                v += 12\n            t[__lu['H']] = v\n\n        elif d == 'y':\n            t[0] = 2000 + int(v) # producing a y3k problem. try find me, then.\n\n        elif d == 'Z':\n            if v.lower() in ['gmt', 'utc']:\n                t[-1] = 0\n\n    # get day of year, costing us an object, to stay safe:\n    __date = __new__(Date(0))\n    __date.setUTCFullYear( t[0] )\n    __date.setUTCMonth(t[1] -1 )\n    __date.setUTCDate( t[2] )\n    __date.setUTCHours(t[3])\n    t[7] = _day_of_year(__date)\n    if not have_weekday:\n        t[6] = __date.getUTCDay() -1\n\n    return t\n\n\ndef strftime(format, t):\n    def zf2(v):\n        ''' zfill missing '''\n        if v < 10:\n            return '0' + str(v)\n        return v\n\n    if not t:\n        t = localtime()\n\n    f = format\n    for d in __lu.keys():\n        k = '%' + d\n        if not k in f:\n            continue\n        v = zf2(t[__lu[d]])\n        f = f.replace(k, v)\n    for d, l, pos in (('b', __months  , 1), ('B', __months_long  , 1),\n                      ('a', __weekdays, 6), ('A', __weekdays_long, 6)):\n        p = t[pos]\n        if pos == 1:\n            p = p -1\n        v = l[p].capitalize()\n        f = f.replace('%' + d, v)\n\n    if '%p' in f:\n        if t[3] > 11:\n            ap = 'PM'\n        else:\n            ap = 'AM'\n        f = f.replace('%p', ap)\n\n    if '%y' in f:\n        f = f.replace('%y', str(t[0])[-2:])\n\n    if '%I' in f:\n        v = t[3]\n        if v == 0:\n            v = 12\n        elif v > 12:\n            v = v - 12\n        f = f.replace('%I', zf2(v))\n\n    return f\n\n",
		"import random\n\nfrom org import threejs as three\nfrom utils import wrap, AABB\n\n\nclass Unit:\n    def __init__(self):\n        self.geo = None\n        self.momentum = three.Vector3(0, 0, 0)\n\n    def get_position(self):\n        return self.geo.position\n\n    def set_position(self, p):\n        self.geo.matrixWorld.setPosition(p)\n\n    def update(self, t):\n        current_pos = self.geo.position\n        move = three.Vector3().copy(self.momentum)\n        move.multiplyScalar(t)\n        self.geo.matrixWorld.setPosition(current_pos.add(move))\n\n    def get_vis(self):\n        return self.geo.visible\n\n    def set_vis(self, v):\n        self.geo.visible = v\n\n    visible = property(get_vis, set_vis)\n    position = property(get_position, set_position)\n\n\nclass Ship(Unit):\n    ROTATE_SPEED = 2.1\n    THRUST = 45\n\n    def __init__(self, keyboard, game):\n        Unit.__init__(self)\n        self.keyboard = keyboard\n\n        self.geo = three.Mesh(\n            three.BoxGeometry(2, 3, 2),\n            three.MeshNormalMaterial()\n        )\n        exhaust = three.Mesh(\n            three.BoxGeometry(1, 2, 1),\n            three.MeshBasicMaterial({'color': 0xffff00})\n        )\n        self.geo.add(exhaust)\n        exhaust.translateY(-2)\n        self.exhaust = exhaust\n        self.momentum = three.Vector3(0, 0, 0)\n        self.keyboard = keyboard\n        self.bbox = AABB(2, 2, self.geo.position)\n        self.game = game\n\n    def thrust(self, amt):\n        thrust_amt = amt * self.THRUST\n        self.momentum = self.momentum.add(self.heading.multiplyScalar(thrust_amt))\n        self.exhaust.visible = amt > 0\n\n    def spin(self, amt):\n        self.geo.rotateZ(amt * self.ROTATE_SPEED * -1)\n\n\n    def update(self, t):\n        Unit.update(self, t)\n        self.bbox.update(self.position)\n\n    def get_heading(self):\n        # return the local Y axis, since Z is 'up'\n        m = self.geo.matrixWorld.elements\n        return three.Vector3(m[4], m[5], m[6])\n\n    heading = property(get_heading)\n\n\nclass Asteroid(Unit):\n    def __init__(self, radius, pos):\n        Unit.__init__(self)\n        self.radius = radius\n        self.geo = three.Mesh(\n            three.SphereGeometry(self.radius),\n            three.MeshNormalMaterial()\n        )\n        self.geo.position.set(pos.x, pos.y, pos.z)\n        self.bbox = AABB(self.radius * 2, self.radius * 2, self.geo.position)\n        self.momentum = three.Vector3(0, 0, 0)\n\n    def update(self, t):\n        Unit.update(self, t)\n        self.bbox.update(self.position)\n\n\nclass Bullet:\n    EXPIRES = 1\n    RESET_POS = three.Vector3(0, 0, 1000)\n    BULLET_SPEED = 50\n\n    def __init__(self):\n        self.vector = three.Vector3(0, 0, 0)\n        self.geo = three.Mesh(\n            three.BoxGeometry(.25, .25, .25),\n            three.MeshBasicMaterial({'color': 0xffffff})\n        )\n        self.lifespan = 0\n        self.momentum = three.Vector3(0, 0, 0)\n        self.reset()\n\n    def update(self, t):\n\n        if self.geo.position.z < 1000:\n            self.lifespan += t\n            if self.lifespan > self.EXPIRES:\n                self.reset()\n                return\n            delta = three.Vector3().copy(self.vector)\n            delta.multiplyScalar(self.BULLET_SPEED * t)\n            delta.add(self.momentum)\n            current_pos = self.geo.position.add(delta)\n            self.geo.position.set(current_pos.x, current_pos.y, current_pos.z)\n            wrap(self.geo)\n\n    def reset(self):\n        self.lifespan = 0\n        self.momentum = three.Vector3(0, 0, 0)\n        self.geo.position.set(self.RESET_POS.x, self.RESET_POS.y, self.RESET_POS.z)\n\n    def get_position(self):\n        return self.geo.position\n\n    position = property(get_position)\n",
		"from org import threejs as three\nfrom org.transcrypt.stubs.browser import __pragma__\n\n\ndef pad_wrap(min, max, val):\n    if val < min:\n        return max\n    if val > max:\n        return min\n    return val\n\n\ndef wrap(obj: three.Object3d):\n    XWRAP = 70\n    XNWRAP = -70\n    YWRAP = 35\n    YNWRAP = -35\n\n    x, y, z = obj.position.x, obj.position.y, obj.position.z\n    x = pad_wrap(XNWRAP, XWRAP, x)\n    y = pad_wrap(YNWRAP, YWRAP, y)\n    obj.position.set(x, y, z)\n\n\ndef clamp(val, low, high):\n    return max(min(val, high), low)\n\n\ndef sign(val):\n    if val > 0:\n        return 1\n    if val < 0:\n        return -1\n    return 0\n\n\ndef now():\n    \"\"\"absolute time in decimal seconds\"\"\"\n    d = __new__(Date)\n    return d.getTime() / 1000.0\n\n\ndef set_element(id, value):\n    document.getElementById(id).innerHTML = value\n\n\nclass AABB:\n    def __init__(self, width, height, center):\n        self.hw = width / 2.0\n        self.hh = width / 2.0\n        self.position = center\n\n    def contains(self, item):\n        x = self.position.x\n        y = self.position.y\n        h = self.hh\n        w = self.hw\n        return item.x > x - w and item.x < x + w and item.y > y - h and item.y < y + h\n\n    def update(self, pos):\n        self.position = pos\n\n\nclass FPSCounter:\n    def __init__(self, hud_element):\n        self.frames = [.1]\n        for n in range(99):\n            self.frames.append(.1)\n        self.next_frame = 0\n        self.average = 0\n        self.visible = True\n        self.element = hud_element\n\n    def update(self, t):\n        self.frames[self.next_frame] = t\n        self.next_frame += 1\n        if self.next_frame > 99:\n            self.next_frame = 0\n\n        sum = lambda a, b: a + b\n        total = 0\n        for n in range(100):\n            total += self.frames[n]\n\n        self.average = total * 10\n        if self.visible:\n            # @todo: need a string formatting option to print out decimal MS\n            self.element.innerHTML = \"{} fps\".format(int(1000 / self.average))\n\n\ndef advance(cr, value):\n    \"\"\"used by coroutines for updating without 'gsend' everywhere\"\"\"\n    __pragma__('gsend')\n    cr.send(value)\n    __pragma__('nogsend')\n\n\ndef coroutine(loop, callback):\n\n    callback_fn = callback if callback is not None else lambda a: a\n\n    def coroutine_generator():\n        alive = True\n        result = None\n        while alive:\n            next_value = yield\n            alive, result = loop(next_value)\n            yield result\n        yield callback_fn(result)\n\n    cr =  coroutine_generator()\n    cr.advance = lambda a: advance(cr, a)\n    return cr\n\n\ndef timer(duration, loop, callback):\n    expires_at = now() + duration\n\n    loop_fn = loop if loop is not None else lambda a: (True, a)\n    callback_fn = callback if callback is not None else lambda a: a\n\n    def timer_coroutine():\n        alive = True\n        result = None\n\n        while alive:\n            next_value = yield\n            alive, result = loop_fn(next_value)\n            alive = alive and now() < expires_at\n            yield result\n        yield callback_fn(result)\n\n    tc = timer_coroutine()\n    tc.advance = lambda a: advance(tc, a)\n    return  tc\n\n\n\n\n    # Context managers don't work'\n    # class TestContext:\n    #\n    #     def __init__(self):\n    #         self.x = True\n    #\n    #     def __enter__(self):\n    #         print (\"entering\")\n    #\n    #     def __exit__(self, exc_type, exc_val, exc_tb):\n    #         print (\"exiting\")\n",
		"# File: transcrypt/modules/warnings/__init__.py\n# Author: Carl Allendorph\n# Date: 20NOV2016\n#\n# Description:\n#   This file contains the implementation of a module to\n# provide features that can be used by developer to flag\n# runtime issues that would not be caught by the static\n# type checking system. These warnings are for conditions\n# that aren't necessarily fatal but denote differences in\n# the transcrypt implementation from the normal cpython\n# implementation\n#\n\n###########################################\n# Transcrypt differences with Python `warnings` module\n#\n# 1) We don't have import/eval so this makes passing\n#       in custom \"Warning\" types hard. To help with this,\n#       I've added a new method \"addWarningCategory\" that\n#       allows the user to add a new warning type via a\n#       programmatic interface.\n# 2) There is a limited subset of warnings right now to keep\n#       things small.\n# 3) catch_warnings is not implemented currently because the\n#       transcrypt framework currently does not support \"with/as\"\n#       clauses very well.\n# 4) This module does not implement the `warn` method. The user\n#       is suggested to use the `warn_explicit` method instead.\n#       In order to prevent cases where a NonImplementedError is\n#       thrown instead of a useful warning, the `warn` method is\n#       not present - forcing the developer to pick a better\n#       solution (like use `warn_explicit`).\n\n# @note - I've moved the re module dependency to the top level because\n#  transcrypt will need to compile and include this regardless if it\n#  gets used or not.\nimport re\n\n\n# Module initialization\n# @note - we don't have command line options - the user must\n#    call the `setWarningOptions` method if they wish to provide\n#    custom warning filtering.\n\n# filters contains a sequence of filter 5-tuples\n# The components of the 5-tuple are:\n# - an action: error, ignore, always, default, module, or once\n# - a compiled regex that must match the warning message\n# - a class representing the warning category\n# - a compiled regex that must match the module that is being warned\n# - a line number for the line being warning, or 0 to mean any line\n# If either if the compiled regexs are None, match anything.\n\nclass Actions:\n    error = \"error\"\n    ignore = \"ignore\"\n    always = \"always\"\n    defaultact = \"default\"\n    module = \"module\"\n    once = \"once\"\n\nActionSet = set([ x for x in dir(Actions) if not x.startswith(\"_\")])\n\n# @note - transcrypt can't use import or eval so we have a map\n#    setup to make our lives easier\nCategoryMap = {\n    \"UserWarning\": UserWarning,\n    \"DeprecationWarning\" : DeprecationWarning,\n    \"RuntimeWarning\" : RuntimeWarning,\n    }\n\n_warnings_defaults = False\n\nfilters = []\ndefaultaction = Actions.defaultact\nonceregistry = {}\n\n_filters_version = 1\n\ndef _filters_mutated():\n    global _filters_version\n    _filters_version += 1\n\n\n# Type definitions - Warnings\n# In CPython, these warnings types seem to be defined in C so there\n# is no lib we can pull from.\n# The definitions of these warning can be found in the __standard__.py\n# file for Transcrypt framework.\n\ndef showwarning(message, category, filename, lineno, file=None, line=None):\n    \"\"\"Hook to write a warning to a file; replace if you like.\"\"\"\n    msg = WarningMessage(message, category, filename, lineno, file, line)\n    _showwarnmsg_impl(msg)\n\ndef formatwarning(message, category, filename, lineno, line=None):\n    \"\"\"Function to format a warning the standard way.\"\"\"\n    msg = WarningMessage(message, category, filename, lineno, None, line)\n    return _formatwarnmsg_impl(msg)\n\ndef _showwarnmsg_impl(msg):\n    \"\"\" Default Show Message Implementation\n    \"\"\"\n    f = msg.file\n    text = _formatwarnmsg(msg)\n    if ( f is None ):\n        # Log to console\n        text = text.rstrip('\\r\\n')\n        console.log(text)\n    else:\n        try:\n            f.write(text)\n        except Exception as exc:\n            # This warning is lost in the aether.\n            pass\n\ndef _formatwarnmsg_impl(msg):\n    \"\"\" @note - we've removed the msg.source handling and the associated\n    tracemalloc code as this isn't available in the js runtime.\n    \"\"\"\n    s = \"{}:{}: {}: {}\\n\".format(\n        msg.filename, msg.lineno, msg.category, str(msg.message)\n        )\n\n    if msg.line:\n        line = msg.line.strip()\n        s += \"  {}\\n\".format(line)\n\n    return s\n\n# Keep a reference to check if the function was replaced\n_showwarning = showwarning\n\ndef setShowWarning(func):\n    \"\"\"\n    \"\"\"\n    if not callable(func):\n        raise TypeError(\"showwarning method must be callable\")\n    global showwarning\n    showwarning = func\n\ndef _showwarnmsg(msg):\n    \"\"\"Hook to write a warning to a file; replace if you like.\"\"\"\n\n    if not callable(showwarning):\n        raise TypeError(\"warnings.showwarning() must be set to a \"\n                        \"function or method\")\n\n    showwarning(msg.message, msg.category, msg.filename, msg.lineno,\n                msg.file, msg.line)\n\n# Keep a reference to check if the function was replaced\n_formatwarning = formatwarning\n\ndef _formatwarnmsg(msg):\n    \"\"\"Function to format a warning the standard way.\"\"\"\n    # @note - transcrypt does not seem to have globals so\n    #    we can't really do this - we pull formatwarning\n    #    from the module namespace.\n    #formatwarning = globals().get('formatwarning', _formatwarning)\n    global formatwarning\n    if formatwarning is not _formatwarning:\n        # warnings.formatwarning() was replaced\n        return formatwarning(msg.message, msg.category,\n                             msg.filename, msg.lineno, line=msg.line)\n    return _formatwarnmsg_impl(msg)\n\n\ndef addWarningCategory(cat):\n    \"\"\" This method allows the user to add a new warning\n    category at runtime from their library set. This is necessary to\n    get around limitations in the transcrypt runtime's lack of\n    import and eval.\n    \"\"\"\n    name = cat.__name__\n    if ( name not in CategoryMap ):\n        CategoryMap[name] = cat\n    else:\n        raise Exception(\"Warning Category {} already exists\".format(name))\n\n\n__pragma__(\"kwargs\")\ndef filterwarnings(action, message=\"\", category=Warning, module=\"\", lineno=0,\n                   append=False):\n    \"\"\"Insert an entry into the list of warnings filters (at the front).\n\n    'action' -- one of \"error\", \"ignore\", \"always\", \"default\", \"module\",\n                or \"once\"\n    'message' -- a regex that the warning message must match\n    'category' -- a class that the warning must be a subclass of\n    'module' -- a regex that the module name must match\n    'lineno' -- an integer line number, 0 matches all warnings\n    'append' -- if true, append to the list of filters\n    \"\"\"\n    assert action in ActionSet , \"invalid action: {}\".format(action)\n    assert isinstance(message, str), \"message must be a string\"\n#    assert issubclass(category, Warning), \"category must be a Warning subclass\"\n    assert isinstance(module, str), \"module must be a string\"\n    assert isinstance(lineno, int) and lineno >= 0, \\\n           \"lineno must be an int >= 0\"\n    _add_filter(action, re.compile(message, re.I), category,\n            re.compile(module), lineno, append=append)\n\ndef simplefilter(action, category=Warning, lineno=0, append=False):\n    \"\"\"Insert a simple entry into the list of warnings filters (at the front).\n\n    A simple filter matches all modules and messages.\n    'action' -- one of \"error\", \"ignore\", \"always\", \"default\", \"module\",\n                or \"once\"\n    'category' -- a class that the warning must be a subclass of\n    'lineno' -- an integer line number, 0 matches all warnings\n    'append' -- if true, append to the list of filters\n    \"\"\"\n    assert action in ActionSet , \"invalid action: {}\".format(action)\n    assert isinstance(lineno, int) and lineno >= 0, \\\n           \"lineno must be an int >= 0\"\n    _add_filter(action, None, category, None, lineno, append=append)\n\ndef _add_filter(*item, append):\n    # Remove possible duplicate filters, so new one will be placed\n    # in correct place. If append=True and duplicate exists, do nothing.\n    if not append:\n        try:\n            filters.remove(item)\n        except Exception: # ValueError was previous here\n            pass\n        filters.insert(0, item)\n    else:\n        if item not in filters:\n            filters.append(item)\n    _filters_mutated()\n__pragma__(\"nokwargs\")\n\ndef resetwarnings():\n    \"\"\"Clear the list of warning filters, so that no filters are active.\"\"\"\n    filters = []\n    _filters_mutated()\n\n\n__warningregistry__ = {}\n\n# @note - The current implementation of transcrypt cannot support\n#    stack traversal so it is very difficult to support a `warnings.warn`\n#    function. In order to prevent runtime conditions where a warning\n#    should have been generated, but instead will generate a extremely\n#    non-helpful \"NotImplementedError\", I'm removing the `warn` function\n#    from the API. This will force developers to use the `warn_explicit`\n#    function instead, leveraging the __filename__, __line__, __name__\n#    macros.\n#\n# def warn(message, category=None, stacklevel=1):\n#     \"\"\"Issue a warning, or maybe ignore it or raise an exception.\"\"\"\n#     raise NotImplementedError(\"Stack info not implemented - use warn_explicit\"))\n\n\ndef _checkCatMatch(msgCat, filtCat):\n    \"\"\"\n    \"\"\"\n    return ( msgCat.__name__ == filtCat.__name__ )\n\ndef warn_explicit(message, category, filename, lineno,\n                  module=None, registry=None, module_globals=None\n                  ):\n    \"\"\" Explicitly set the message and origin information for a warning.\n    This is the preferred method to use in transcrypt.\n    @param message message for the warning that will be created.\n    @param category object that subclasses `Warning` and indicates the\n       type of warning being created. @see addWarningCategory for\n       extensibility\n    @param filename name of the file from which this warning is originating.\n       @note use the __file__ and __filename__ macro definitions for this.\n       In general, this should refer to the python source file or if that\n       does not exist a pure js file.\n    @param lineno The line number in the associated source file that this\n       warning is being generated at. @note use the __line__ macro.\n    @param module name of the module that is generating this warning.\n       @note use the __name__ macro as a mechanism for creating this\n       string.\n    @param registry This parameter is used to reference the data storage\n       location which houses the state of warnings that have been\n       generated. In most applications, you should leave this value as\n       None. If this value is None, then the internal `warnings` module\n       registry will be used by default. @note this is a deviation from\n       the python standard API.\n    @param module_globals This parameter is carry over from the python\n       implementation and provided to keep the API the same. This\n       parameter is currently not used.\n    \"\"\"\n    lineno = int(lineno)\n    if module is None:\n        module = filename or \"<unknown>\"\n        if module[-3:].lower() == \".py\":\n            module = module[:-3] # XXX What about leading pathname?\n    if registry is None:\n        # @note - this is a departure from the original python\n        #    implementation - we are going to pull registry from\n        #    the __warningregistry__ module level variable\n        #    instead of just a blank registry\n        registry = __warningregistry__\n        #registry = {}\n\n    try:\n        currVersion = registry[\"version\"]\n    except KeyError:\n        currVersion = 0\n\n    if currVersion != _filters_version:\n        registry.clear()\n        registry['version'] = _filters_version\n\n    if isinstance(message, Warning):\n        text = str(message)\n        category = message.__class__\n    else:\n        text = message\n        message = category(message)\n    key = (text, category, lineno)\n    # Quick test for common case\n    if key in registry:\n        return\n\n    # Search the filters\n    for item in filters:\n        action, msg, cat, mod, ln = item\n        if ((msg is None or msg.match(text)) and\n            # @note - No issubclass so we will attempt to match\n            #    the category of the message to the filter's cat\n            #    in a different way.\n            #issubclass(category, cat) and #@note - no issubclass yet\n            _checkCatMatch(category, cat) and\n\n            (mod is None or mod.match(module)) and\n            (ln == 0 or lineno == ln)):\n            break\n    else:\n        action = defaultaction\n    # Early exit actions\n    if action == Actions.ignore:\n        registry[key] = 1\n        return\n\n    # Prime the linecache for formatting, in case the\n    # \"file\" is actually in a zipfile or something.\n    #import linecache\n    #linecache.getlines(filename, module_globals)\n\n    if action == Actions.error:\n        raise message\n    # Other actions\n    if action == Actions.once:\n        registry[key] = 1\n        oncekey = (text, category)\n        if oncekey in onceregistry:\n            return\n        onceregistry[oncekey] = 1\n    elif action == Actions.always:\n        pass\n    elif action == Actions.module:\n        registry[key] = 1\n        altkey = (text, category, 0)\n        if altkey in registry:\n            return\n        registry[altkey] = 1\n    elif action == Actions.defaultact:\n        registry[key] = 1\n    else:\n        # Unrecognized actions are errors\n        raise RuntimeError(\"Unrecognized action ({}) in warnings.filters:\\n {}\".format(action, item))\n    # Print message and context\n    msg = WarningMessage(message, category.__name__, filename, lineno)\n    _showwarnmsg(msg)\n\n\nclass WarningMessage(object):\n\n    def __init__(self, message, category, filename, lineno, file=None,\n                 line=None):\n        self.message = message\n        self.category = category\n        self.filename = filename\n        self.lineno = lineno\n        self.file = file\n        self.line = line\n\n        self._category_name = category.__name__ if category else None\n\n    def __str__(self):\n        return (\"{{message : {}, category : {}, filename : {}, lineno : {}, \"\n                \"line : {} }}\".format(self.message, self._category_name,\n                                      self.filename, self.lineno, self.line))\n\n# @note - Currently transcrypt does not support \"with/as\" clauses so\n#    this is currently not going to work. As such, this class will\n#    throw an exception when the user tries to use it.\nclass catch_warnings(object):\n    \"\"\"A context manager that copies and restores the warnings filter upon\n    exiting the context.\n\n    The 'record' argument specifies whether warnings should be captured by a\n    custom implementation of warnings.showwarning() and be appended to a list\n    returned by the context manager. Otherwise None is returned by the context\n    manager. The objects appended to the list are arguments whose attributes\n    mirror the arguments to showwarning().\n\n    The 'module' argument is to specify an alternative module to the module\n    named 'warnings' and imported under that name. This argument is only useful\n    when testing the warnings module itself.\n\n    \"\"\"\n\n    def __init__(self, *, record=False, module=None):\n        \"\"\"Specify whether to record warnings and if an alternative module\n        should be used other than sys.modules['warnings'].\n\n        For compatibility with Python 3.0, please consider all arguments to be\n        keyword-only.\n\n        \"\"\"\n        self._record = record\n        #self._module = sys.modules['warnings'] if module is None else module\n        self._entered = False\n        raise NotImplementedError(\"with/as not well supported in transcrypt\")\n\n    # def __repr__(self):\n    #     args = []\n    #     if self._record:\n    #         args.append(\"record=True\")\n    #     if self._module is not sys.modules['warnings']:\n    #         args.append(\"module=%r\" % self._module)\n    #     name = type(self).__name__\n    #     return \"%s(%s)\" % (name, \", \".join(args))\n\n    # def __enter__(self):\n    #     if self._entered:\n    #         raise RuntimeError(\"Cannot enter %r twice\" % self)\n    #     self._entered = True\n    #     self._filters = self._module.filters\n    #     self._module.filters = self._filters[:]\n    #     self._module._filters_mutated()\n    #     self._showwarning = self._module.showwarning\n    #     self._showwarnmsg = self._module._showwarnmsg\n    #     if self._record:\n    #         log = []\n    #         def showarnmsg(msg):\n    #             log.append(msg)\n    #         self._module._showwarnmsg = showarnmsg\n    #         return log\n    #     else:\n    #         return None\n\n    # def __exit__(self, *exc_info):\n    #     if not self._entered:\n    #         raise RuntimeError(\"Cannot exit %r without entering first\" % self)\n    #     self._module.filters = self._filters\n    #     self._module._filters_mutated()\n    #     self._module.showwarning = self._showwarning\n    #     self._module._showwarnmsg = self._showwarnmsg\n\n\n############################################################\n# Warnings Module Options\n# Configuration Methods\n############################################################\n\ndef setWarningOptions(opts):\n    \"\"\" This method can be used to configured the filters for the\n    warning module.\n    @param opts List of strings in the form\n      \"action:message:category:module:line\"\n      where action is string in the set `warnings.ActionSet`\n      @see the python documentation for more info.\n    \"\"\"\n    _processoptions(opts)\n\nclass _OptionError(Exception):\n    \"\"\"Exception used by option processing helpers.\"\"\"\n    pass\n\n# Helper to process -W options passed via sys.warnoptions\ndef _processoptions(args):\n    for arg in args:\n        try:\n            _setoption(arg)\n        except _OptionError as msg:\n            console.log(\"WARNING: Invalid -W option ignored: {}\".format(msg))\n\n# Helper for _processoptions()\ndef _setoption(arg):\n    parts = arg.split(':')\n    if len(parts) > 5:\n        raise _OptionError(\"too many fields (max 5): {}\".format(arg))\n    while len(parts) < 5:\n        parts.append('')\n    action, message, category, module, lineno = [s.strip() for s in parts]\n    action = _getaction(action)\n    message = re.escape(message)\n    category = _getcategory(category)\n    module = re.escape(module)\n    if module:\n        module = module + '$'\n    if lineno:\n        try:\n            lineno = int(lineno)\n            if lineno < 0:\n                raise ValueError\n        except (ValueError, OverflowError):\n            raise _OptionError(\"invalid lineno {}\".format(lineno))\n    else:\n        lineno = 0\n    filterwarnings(action, message, category, module, lineno)\n\n# Helper for _setoption()\ndef _getaction(action):\n    if not action:\n        return Actions.defaultact\n    if action == \"all\": return Action.always # Alias\n    for a in ActionSet:\n        if a.startswith(action):\n            return a\n    raise _OptionError(\"invalid action: {}\".format(action))\n\n# Helper for _setoption()\ndef _getcategory(category):\n    if not category:\n        return Warning\n    if ( category in CategoryMap.keys() ):\n        try:\n            cat = CategoryMap[category]\n        except NameError:\n            raise _OptionError(\"unknown warning category: {}\".format(category))\n    else:\n        # @note - transcrypt does not have the ability to import\n        raise Exception(\"Unable to import category: {}, use `addWarningCategory`\".format(category))\n        # i = category.rfind(\".\")\n        # module = category[:i]\n        # klass = category[i+1:]\n        # try:\n        #     m = __import__(module, None, None, [klass])\n        # except ImportError:\n        #     raise _OptionError(\"invalid module name: %r\" % (module,))\n        # try:\n        #     cat = getattr(m, klass)\n        # except AttributeError:\n        #     raise _OptionError(\"unknown warning category: %r\" % (category,))\n    #if not issubclass(cat, Warning):\n    #    raise _OptionError(\"invalid warning category: {}\".format(category))\n    return cat\n\nif not _warnings_defaults:\n    #silence = [ImportWarning, PendingDeprecationWarning]\n    silence = [DeprecationWarning]\n    for cls in silence:\n        simplefilter(Actions.ignore, category=cls)\n    # bytes_warning = sys.flags.bytes_warning\n    # if bytes_warning > 1:\n    #     bytes_action = Actions.error\n    # elif bytes_warning:\n    #     bytes_action = Actions.defaultact\n    # else:\n    #     bytes_action = Actions.ignore\n    # simplefilter(bytes_action, category=BytesWarning, append=1)\n    # resource usage warnings are enabled by default in pydebug mode\n    # if hasattr(sys, 'gettotalrefcount'):\n    #     resource_action = Actions.always\n    # else:\n    #     resource_action = Actions.ignore\n    # simplefilter(resource_action, category=ResourceWarning, append=1)\n\n#del _warnings_defaults\n",
		"import logging\nimport random\n\nimport org.threejs as three\nfrom controls import Keyboard, ControlAxis\nfrom units import Ship, Asteroid, Bullet\nfrom utils import wrap, now, FPSCounter, timer, coroutine, clamp\nimport audio\nfrom org.transcrypt.stubs.browser import __pragma__\n\nDEBUG = True\nlogger = logging.getLogger('root')\nlogger.addHandler(logging.StreamHandler())\n\nif DEBUG:\n    logger.setLevel(logging.INFO)\n    logger.info(\"====== debug logging on =====\")\n\n\ndef waiter(*args):\n    return True, args[0]\n\n\ndef done(*args):\n    print(\"done at\", args[0])\n\n\nclass Graphics:\n    def __init__(self, w, h, canvas):\n        self.width = float(w)\n        self.height = float(h)\n        self.scene = three.Scene()\n        self.camera = three.PerspectiveCamera(53.13, self.width / self.height, 1, 500)\n        self.camera.position.set(0, 0, 80)\n        self.camera.lookAt(self.scene.position)\n        self.renderer = three.WebGLRenderer({'Antialias': True})\n        self.renderer.setSize(self.width, self.height)\n        canvas.appendChild(self.renderer.domElement)\n\n    def render(self):\n        self.renderer.render(self.scene, self.camera)\n\n    def add(self, item):\n        self.scene.add(item.geo)\n\n\nclass Audio:\n    def __init__(self):\n        self.fire_rota = [audio.clip('344276__nsstudios__laser3.wav'),\n                          audio.clip('344276__nsstudios__laser3.wav'),\n                          audio.clip('344276__nsstudios__laser3.wav'),\n                          audio.clip('344276__nsstudios__laser3.wav')]\n        self.explosion_rota = [audio.clip('108641__juskiddink__nearby-explosion-with-debris.wav'),\n                               audio.clip('108641__juskiddink__nearby-explosion-with-debris.wav'),\n                               audio.clip('108641__juskiddink__nearby-explosion-with-debris.wav'),\n                               audio.clip('108641__juskiddink__nearby-explosion-with-debris.wav'), ]\n        self.thrust = audio.loop('146770__qubodup__rocket-boost-engine-loop.wav')\n        self.fail = audio.clip('172950__notr__saddertrombones.mp3')\n        self.thrust.play()\n        self.shoot_ctr = 0\n        self.explode_ctr = 0\n\n    def fire(self):\n        self.fire_rota[self.shoot_ctr % 4].play()\n        self.shoot_ctr += 1\n\n    def explode(self):\n        self.explosion_rota[self.shoot_ctr % 4].play()\n        self.shoot_ctr += 1\n\n\nclass Game:\n    def __init__(self, canvas):\n        self.keyboard = Keyboard()\n        self.graphics = Graphics(window.innerWidth - 32, window.innerHeight - 32, canvas)\n        self.create_controls()\n        self.ship = None\n        self.bullets = []\n        self.asteroids = []\n        self.setup()\n        self.last_frame = now()\n        self.audio = Audio()\n        self.lives = 3\n        self.resetter = None\n\n        logging.warning(document.getElementById(\"FPS\"))\n        self.fps_counter = FPSCounter(document.getElementById(\"FPS\"))\n\n        # adjust the position of the game over div\n        v_center = (window.innerHeight - 120) / 2.0\n        title = document.getElementById(\"game_over\")\n        title.style.top = v_center\n\n    def create_controls(self):\n        self.keyboard.add_handler('spin', ControlAxis('ArrowRight', 'ArrowLeft', attack=1, decay=.6))\n        self.keyboard.add_handler('thrust', ControlAxis('ArrowUp', 'ArrowDown', attack=.75, decay=2, deadzone=.1))\n        self.keyboard.add_handler('fire', ControlAxis(' ', 'None', attack=10))\n        document.onkeydown = self.keyboard.key_down\n        document.onkeyup = self.keyboard.key_up\n\n    def setup(self):\n\n        self.ship = Ship(self.keyboard, self)\n\n        self.graphics.add(self.ship)\n\n        def rsign():\n            if random.random() < .5:\n                return -1\n            return 1\n\n        for a in range(8):\n            x = (random.random() - 0.5) * 2\n            y = random.random() - 0.5\n            z = 0\n            offset = three.Vector3(x, y, z)\n            offset.normalize();\n            push = random.randint(20, 60)\n            offset = offset.multiplyScalar(push)\n\n            r = (random.random() + 1.0) * 2.5\n            asteroid = Asteroid(r, offset)\n\n            mx = random.random() + random.random() + random.random(2) - 2.0\n            my = random.random() + random.random() + random.random(2) - 2.0\n            asteroid.momentum = three.Vector3(mx, my, 0)\n\n            self.graphics.add(asteroid)\n            self.asteroids.append(asteroid)\n\n        for b in range(8):\n            bullet = Bullet()\n            self.graphics.add(bullet)\n            self.bullets.append(bullet)\n\n    def tick(self):\n\n        if len(self.asteroids) == 0 or self.lives < 1:\n            document.getElementById(\"game_over\").style.zIndex = 10\n            return\n\n        requestAnimationFrame(self.tick)\n\n        t = (now() - self.last_frame)\n\n        self.fps_counter.update(t)\n        self.keyboard.update(t)\n\n        # controls\n        self.handle_input(t)\n\n        # clean up bullets, check for collisions\n        dead = []\n        for b in self.bullets:\n            if b.position.z < 1000:\n                for a in self.asteroids:\n                    if a.bbox.contains(b.position):\n                        d = a.geo.position.distanceTo(b.position)\n                        if d < a.radius:\n                            b.reset()\n                            dead.append(a)\n\n        if self.ship.visible:\n            for a in self.asteroids:\n                if a.bbox.contains(self.ship.position):\n                    d = a.geo.position.distanceTo(self.ship.position)\n                    if d < (a.radius + 0.5):\n                        self.resetter = self.kill()\n                        dead.append(a)\n        else:\n            self.resetter.advance(t)\n\n        for d in dead:\n            self.asteroids.remove(d)\n            d.geo.visible = False\n            if d.radius > 1.5:\n                self.audio.explode()\n                new_asteroids = random.randint(2, 5)\n                for n in range(new_asteroids):\n                    new_a = Asteroid((d.radius + 1.0) / new_asteroids, d.position)\n                    mx = (random.random() - 0.5) * 6\n                    my = (random.random() - 0.5) * 4\n                    new_a.momentum = three.Vector3().copy(d.momentum)\n                    new_a.momentum.add(three.Vector3(mx, my, 0))\n                    self.graphics.add(new_a)\n                    self.asteroids.append(new_a)\n\n        for b in self.bullets:\n            b.update(t)\n\n        self.ship.update(t)\n        wrap(self.ship.geo)\n\n        for item in self.asteroids:\n            item.update(t)\n            wrap(item.geo)\n\n        if self.resetter is not None:\n            self.resetter.advance(t)\n\n        self.graphics.render()\n        self.last_frame = now()\n\n    def handle_input(self, t):\n\n        if self.keyboard.get_axis('fire') >= 1:\n            mo = three.Vector3().copy(self.ship.momentum).multiplyScalar(t)\n            if self.fire(self.ship.position, self.ship.heading, mo):\n                self.audio.fire()\n            self.keyboard.clear('fire')\n\n        spin = self.keyboard.get_axis('spin')\n        self.ship.spin(spin * t)\n\n        thrust = self.keyboard.get_axis('thrust')\n        self.audio.thrust.volume = clamp(thrust * 5, 0, 1)\n        self.ship.thrust(thrust * t)\n\n    def fire(self, pos, vector, momentum, t):\n        for each_bullet in self.bullets:\n            if each_bullet.geo.position.z >= 1000:\n                each_bullet.geo.position.set(pos.x, pos.y, pos.z)\n                each_bullet.vector = vector\n                each_bullet.lifespan = 0\n                each_bullet.momentum = three.Vector3().copy(momentum).multiplyScalar(.66)\n                return True\n        return False\n\n    def kill(self):\n        self.lives -= 1\n        self.ship.momentum = three.Vector3(0, 0, 0)\n        self.ship.position = three.Vector3(0,0,0)\n        self.ship.geo.matrixWorldNeedsUpdate = True\n        self.ship.visible = False\n        can_reappear = now() + 5\n\n        def reappear(t):\n            if now() < can_reappear:\n                return True, \"waiting\"\n            for a in self.asteroids:\n                if a.bbox.contains(self.ship.position):\n                    return True, \"can't spawn\"\n            return False, \"OK\"\n\n        def clear_resetter():\n            self.ship.visible = True\n            self.resetter = None\n\n        reset = coroutine(reappear, clear_resetter)\n\n        next(reset)\n        return reset\n\n\ncanvas = document.getElementById(\"game_canvas\")\ngame = Game(canvas)\n\ngame.tick()\n"
	],
	"mappings": "AAAA;AAAA;AAAA;AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ACXA;AAAA;AAAA;AAAA;AAAA;AAAA;AAaA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAMA;AAAA;AAKA;AAAA;AAGA;AAAA;AAGA;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAIA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAoFA;AAUA;AACA;AAEA;AACA;AAAA;AAAA;AAEA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ACrPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/yDA;AAAA;AAAA;AAAA;AAAA;AAAA;AA8BA;AA9BA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AACA;AAA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AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAEA;AAIA;AACA;AAAA;AACA;AAAA;AAEA;AAIA;AAAA;AAEA;AAIA;AAAA;AAEA;AAIA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAIA;AAEA;AAIA;AACA;AAEA;AACA;AACA;AAIA;AAAA;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA0CA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AASA;AAAA;AAAA;AAAA;AAMA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AACA;AAAA;AACA;AAAA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AACA;AAAA;AACA;AAAA;AAGA;AAIA;AAAA;AAEA;AAAA;AAAA;AAAA;AAOA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWA;AAUA;AAAA;AAGA;AAAA;AAGA;AACA;AAAA;AAAA;AAIA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAEA;AAOA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ACtgEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ACxYA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;AAGA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAMA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AC9CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAcA;AAKA;AACA;AAEA;AACA;AAGA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AAIA;AACA;AAIA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AAAA;AAAA;AAGA;AAIA;AACA;AAAA;AAAA;AAEA;AAGA;AAAA;AAAA;AAAA;AAQA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAAA;AACA;AAIA;AAAA;AAAA;AAGA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AAGA;AACA;AACA;AACA;AAAA;AAAA;AAGA;AAAA;AACA;AAEA;AAAA;AAAA;AAEA;AAGA;AAAA;AAAA;AAAA;AAEA;AAAA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAIA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAKA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAMA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAUA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAWA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAUA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAWA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;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EA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AACA;AAEA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAEA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAGA;AACA;AAAA;AACA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAKA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ACpVA;AAAA;AAAA;AAAA;AAAA;AAAA;AA2BA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AAIA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AASA;AAEA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAGA;AAWA;AAEA;AAAA;AAEA;AAWA;AAEA;AAAA;AAEA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAEA;AAWA;AACA;AAGA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AAEA;AAAA;AAGA;AAEA;AACA;AAAA;AAAA;AAGA;AAAA;AAAA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AASA;AACA;AAEA;AACA;AAAA;AACA;AAEA;AAEA;AAEA;AAGA;AAMA;AAAA;AAGA;AACA;AAAA;AAGA;AAEA;AACA;AAAA;AAGA;AAQA;AACA;AAAA;AACA;AAAA;AAGA;AAQA;AACA;AAAA;AACA;AAAA;AAGA;AAQA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAIA;AA+BA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AAGA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAGA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAIA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAGA;AAAA;AAAA;AAGA;AACA;AAAA;AAAA;AAGA;AACA;AAAA;AAEA;AAGA;AACA;AAAA;AAGA;AAGA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAEA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAGA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AAGA;AACA;AAEA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AC3fA;AAAA;AAAA;AAAA;AAAA;AAAA;AAoIA;AApIA;AAEA;AACA;AAAA;AAGA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AAEA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AAIA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAGA;AACA;AACA;AAAA;AAEA;AAEA;AACA;AAAA;AAAA;AAEA;AAGA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AAEA;AACA;AAGA;AAEA;AACA;AACA;AAAA;AAEA;AAEA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ACpIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAGA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAGA;AACA;AAAA;AAGA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAGA;AAEA;AACA;AAAA;AAGA;AACA;AAAA;AAGA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAGA;AACA;AAEA;AAAA;AAAA;AAAA;AAGA;AAGA;AACA;AAGA;AAEA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AAGA;AACA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;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;AAAA;AACA;AAEA;AAAA;AAAA;AAAA;AAcA;AAAA;AAEA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ACziBA;AAiQA;AAAA;AAAA;AAjQA;AACA;AAEA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAGA;AAAA;AACA;AAAA;AAGA;AAAA;AACA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AAGA;AACA;AAIA;AAIA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AAGA;AACA;AAAA;AAAA;AAAA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AAAA;AAEA;AAEA;AAEA;AACA;AAGA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AAEA;AAEA;AACA;AAAA;AAAA;AAGA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA"
}